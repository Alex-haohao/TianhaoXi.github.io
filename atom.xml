<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://TianhaoXi.github.io</id>
    <title>Alex个人博客</title>
    <updated>2020-08-29T00:10:03.022Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://TianhaoXi.github.io"/>
    <link rel="self" href="https://TianhaoXi.github.io/atom.xml"/>
    <subtitle>学习，分享，进步</subtitle>
    <logo>https://TianhaoXi.github.io/images/avatar.png</logo>
    <icon>https://TianhaoXi.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Alex个人博客</rights>
    <entry>
        <title type="html"><![CDATA[寻找document全部节点]]></title>
        <id>https://TianhaoXi.github.io/post/xun-zhao-document-quan-bu-jie-dian/</id>
        <link href="https://TianhaoXi.github.io/post/xun-zhao-document-quan-bu-jie-dian/">
        </link>
        <updated>2020-08-28T07:33:31.000Z</updated>
        <content type="html"><![CDATA[<p>function getElCount(n){                     //定义文档元素统计函数<br>
var num = 0;                            //初始化变量<br>
if(n.nodeType == 1){                    //检查是否为元素节点<br>
num++;                              //如果是，计数器加1<br>
console.log(n.nodeName);            //输出元素节点名称<br>
}<br>
var son = n.childNodes;                 //获取所有子节点<br>
for(var i=0 ; i&lt;son.length ; i++){      //遍历每个子元素<br>
num += getElCount(son[i]);    //递归操作<br>
}<br>
return num;                             //返回统计值<br>
}<br>
window.onload=function(){<br>
console.log('文档中元素节点的个数是：'+getElCount(document)+'个')<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[全排列]]></title>
        <id>https://TianhaoXi.github.io/post/quan-pai-lie/</id>
        <link href="https://TianhaoXi.github.io/post/quan-pai-lie/">
        </link>
        <updated>2020-08-22T12:03:05.000Z</updated>
        <content type="html"><![CDATA[<p>var permute = function(nums) {<br>
const list = [];<br>
backtrack(list, [], nums)<br>
return list<br>
};</p>
<p>function backtrack(list,templist,num){<br>
if(templist.length === num.length){<br>
list.push([...templist])<br>
}<br>
for(let i=0;i&lt;num.length;i++){<br>
if(templist.includes(num[i])){<br>
continue;<br>
}<br>
templist.push(num[i]);<br>
backtrack(list,templist,num);<br>
templist.pop()<br>
}<br>
}</p>
<p>var permute = function(nums) {<br>
let n = nums.length;<br>
nums = nums.sort((a,b) =&gt; {return a - b});<br>
let res = [];<br>
let tmpPath = [];<br>
let hash = {};<br>
let backtrack = (tmpPath) =&gt; {<br>
if(tmpPath.length == n){<br>
res.push(tmpPath);<br>
return;<br>
}<br>
for(let i = 0;i &lt; n;i++){<br>
if(hash[i] || (i &gt; 0 &amp;&amp; !hash[i-1] &amp;&amp; nums[i-1] == nums[i])) continue;<br>
hash[i] = true;<br>
tmpPath.push(nums[i]);<br>
backtrack([...tmpPath]);<br>
hash[i] = false;<br>
tmpPath.pop();<br>
}<br>
}<br>
backtrack(tmpPath);<br>
return res;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[merge sort]]></title>
        <id>https://TianhaoXi.github.io/post/merge-sort/</id>
        <link href="https://TianhaoXi.github.io/post/merge-sort/">
        </link>
        <updated>2020-08-22T08:06:15.000Z</updated>
        <content type="html"><![CDATA[<p>// merge Sort<br>
function mergeSort(arr) { // 采用自上而下的递归方法<br>
var length = arr.length;<br>
if (length &lt; 2) {<br>
return arr;<br>
}</p>
<pre><code>var middle = Math.floor(length / 2);
var left = arr.slice(0, middle);
var right = arr.slice(middle);

return merge(mergeSort(left), mergeSort(right));
</code></pre>
<p>}</p>
<p>function merge(left, right) {<br>
var result = [];<br>
console.log('left', left, 'right', right);<br>
while (left.length &amp;&amp; right.length) {<br>
if (left[0] &lt;= right[0]) {<br>
result.push(left.shift());<br>
} else {<br>
result.push(right.shift());<br>
}<br>
}</p>
<pre><code>while (left.length) {
  result.push(left.shift());
}

while (right.length) {
  result.push(right.shift());
}
return result;
</code></pre>
<p>}</p>
<p>var array = [3,5,1,2,3,5,6,7]<br>
var result = mergeSort(array);<br>
console.log(result)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[matrix_clodckspin]]></title>
        <id>https://TianhaoXi.github.io/post/matrix_clodckspin/</id>
        <link href="https://TianhaoXi.github.io/post/matrix_clodckspin/">
        </link>
        <updated>2020-08-22T08:04:52.000Z</updated>
        <content type="html"><![CDATA[<p>function printMatrix(matrix)<br>
{<br>
// write code here</p>
<pre><code>var row = matrix.length;
var col = matrix[0].length;
   

var res = [];
if(row ==0 || col == 0){
    return null;
}

var left = 0; var right = col - 1; var top=0; var bottom = row-1;

while(left&lt;= right &amp;&amp; top &lt;= bottom ){
    
    for(var i =left; i&lt;= right; i++){
        res.push(matrix[top][i]);
    }
    for(var i = top+1; i&lt;= bottom;i++ ){
        res.push(matrix[i][right]);
    }
    if(top != bottom){
        for (var i = right-1;i&gt;= left;i--){
            res.push(matrix[bottom][i]);
        }
    }
    if(left != right){
        for (var i = bottom-1 ; i&gt; top;i--){
            res.push(matrix[i][left]);
        }
    }
  left = left+1;  
  top = top+1;
  right = right -1;
   bottom = bottom -1; 
}
return res;
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quick sort]]></title>
        <id>https://TianhaoXi.github.io/post/quick-sort/</id>
        <link href="https://TianhaoXi.github.io/post/quick-sort/">
        </link>
        <updated>2020-08-22T08:04:33.000Z</updated>
        <content type="html"><![CDATA[<p>// quick sort</p>
<p>function quicksort(array){<br>
if(array.length&lt;2){<br>
return array;<br>
}</p>
<pre><code>var piviotindex = Math.floor(array.length/2)
var pivot = array.splice(piviotindex,1)[0];
var left =[];
var right = [];

for(var i =0;i&lt;array.length;i++){
    if(array[i]&lt;pivot){
        left.push(array[i])
    }
    else{
        right.push(array[i])
    }
}

return quicksort(left).concat([pivot],quicksort(right))
</code></pre>
<p>}</p>
<p>////////////////////<br>
function quickSort(arr, left, right) {<br>
if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof length === 'number' &amp;&amp; typeof right === 'number') {</p>
<pre><code>  if (left &lt; right) {
    var pivot = arr[left]; // 起始位置
    var setPos = left + 1; // 设置的位置
    for (var i = left + 1; i &lt;= right; i++) {
      if (arr[i] &lt; pivot) {
        swap(arr,i,setPos)
        setPos++;
      }
    }
    // 循环完成之后将key与 pos-1的位置交换
    swap(arr,left,setPos-1)

    // console.log('每一次排序', '当前key值===&gt;', key, '排序完成当前数组===&gt;', JSON.stringify(arr));

    quickSort(arr, left, setPos - 2);
    quickSort(arr, setPos, right);
    // console.log('arr=======&gt;', arr);
  }
} else {
  return 'array is not an Array or left or right is not a number!';
}
return arr;
</code></pre>
<p>}</p>
<p>function swap(obj, a, b) { var tmp = obj[a]; obj[a] = obj[b]; obj[b] = tmp; }</p>
<p>var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];<br>
// var arr = [7, 3, 2, 10, 13, 8, 5];<br>
console.log(quickSort(arr, 0, arr.length - 1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Heap sort]]></title>
        <id>https://TianhaoXi.github.io/post/heap-sort/</id>
        <link href="https://TianhaoXi.github.io/post/heap-sort/">
        </link>
        <updated>2020-08-22T08:02:40.000Z</updated>
        <content type="html"><![CDATA[<p>function swap(obj, a, b) { var tmp = obj[a]; obj[a] = obj[b]; obj[b] = tmp; }</p>
<p>function bubbleup(array,index){<br>
const parentindex = Math.floor((index-1)/2)<br>
if(array[parentindex] &amp;&amp; array[parentindex]&lt;array[index]){<br>
swap(array,parentindex,index)<br>
bubbleup(array,parentindex);<br>
}<br>
return;<br>
}</p>
<p>function bubbledown(arr,index,size){<br>
var left = index * 2 + 1;<br>
while (left &lt; size) {<br>
var largest = left + 1 &lt; size &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;<br>
largest = arr[largest] &gt; arr[index] ? largest : index;<br>
if (largest == index) {<br>
break;<br>
}<br>
swap(arr, largest, index);<br>
index = largest;<br>
left = index * 2 + 1;<br>
}<br>
}</p>
<p>function heapSort(arr) {<br>
if (arr == null || arr.length &lt; 2) {<br>
return;<br>
}</p>
<pre><code>for (var i = 0; i &lt; arr.length; i++) {
    bubbleup(arr, i);
}
var size = arr.length;
swap(arr, 0, --size);
while (size &gt; 0) {
    bubbledown(arr, 0, size);
    swap(arr, 0, --size);
}
</code></pre>
<p>}</p>
<p>var arr = [91, 60, 96, 13, 35, 65, 46, 65, 10, 30, 20, 31, 77, 81, 22];<br>
heapSort(arr);<br>
console.log(arr)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划常见题]]></title>
        <id>https://TianhaoXi.github.io/post/dong-tai-gui-hua-chang-jian-ti/</id>
        <link href="https://TianhaoXi.github.io/post/dong-tai-gui-hua-chang-jian-ti/">
        </link>
        <updated>2020-08-22T03:25:36.000Z</updated>
        <content type="html"><![CDATA[<p>代金券组合😎dp<br>
function coinChange(coins,amount){<br>
let dp = new Array(amount+1).fill(Infinity)<br>
dp[0]=0;<br>
for(let coin of coins){<br>
for(let i =1;i&lt;=amount;i++){<br>
if(i-coin&gt;=0){<br>
dp[i]=Math.min(dp[i],dp[i-coin]+1)<br>
}<br>
}<br>
}</p>
<pre><code>return dp[amount] === Infinity ? 'Impossible' : dp[amount];
</code></pre>
<p>}</p>
<p>最小路径和：<br>
function minPath(grid){<br>
let m = grid.length;<br>
let n = grid[0].length;</p>
<pre><code>for(let i =m-1;i&gt;=0;i--){
    for(let j=n-1;j&gt;=0;j--){
        if (i + 1 &lt; m &amp;&amp; j + 1 &lt; n) {
            grid[i][j] += Math.min(grid[i + 1][j], grid[i][j + 1])
        } else if (i + 1 &lt; m) {
            grid[i][j] += grid[i + 1][j]
        } else if (j + 1 &lt; n) {
            grid[i][j] += grid[i][j + 1]
        }
    }
}
return grid[0][0];   
</code></pre>
<p>}</p>
<p>01 背包<br>
var line=readline().split(' ');<br>
var N=parseInt(line[0]);//承重<br>
var c=parseInt(line[1]);//数量<br>
var w=[0],p=[0];//重 价值<br>
while(lines=readline()){<br>
let nums=lines.split(' ').map(Number);<br>
p.push(nums[0])//;<br>
w.push(nums[1]);<br>
}<br>
function DyadicArray(N, c, w, p) {<br>
//初始化表格<br>
var dp = new Array(N + 1); //表格有n+1行<br>
for (let n = 0; n &lt; N + 1; n++) {<br>
dp[n] = new Array(c + 1).fill(0); //每行有c+1列<br>
}</p>
<p>for (let i = 1; i &lt;= N; i++) {<br>
for (let j = 0; j &lt;= c; j++) {<br>
if (j - w[i] &gt;= 0) {<br>
dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w[i]] + p[i]);<br>
} else {<br>
dp[i][j] = dp[i - 1][j];<br>
}<br>
}<br>
}<br>
return(dp[N][c])<br>
}<br>
console.log(DyadicArray(N, c, w, p))</p>
<p>最长公共子序列</p>
<p>var longestCommonSubsequence = function(text1, text2) {<br>
let n = text1.length;<br>
let m = text2.length;<br>
let dp = Array.from(new Array(n+1),() =&gt; new Array(m+1).fill(0));</p>
<pre><code>for(let i =1;i&lt;=n;i++){
    for(let j=1;j&lt;=m;j++){
        if(text1[i-1]===text2[j-1]){
            dp[i][j] = 1+dp[i-1][j-1];
        }
        else{
            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])
        }
    }
}
return dp[n][m]
</code></pre>
<p>};</p>
<p>01 背包：<br>
function kanpSack(capacity, weights, values, n) {<br>
var a,b,dp = []</p>
<p>//首先，初始化用于寻找解决方案的矩阵KS[n+1][capacity+1]<br>
for (var i = 0; i &lt;= n; i++) {<br>
dp[i] = [];<br>
}<br>
for (var i = 0; i &lt;= n; i++) {<br>
for (var j = 0; j &lt;= capacity; j++) {<br>
if (i === 0 || j === 0) {<br>
//让第一行和第一列为0，因为第一行和第一列表示容量为0或没有物品可装<br>
dp[i][j] = 0;<br>
} else if (weights[i - 1] &gt; j) {<br>
dp[i][j] = dp[i - 1][j]; //当前物品重量大于当前容量<br>
} else {<br>
//当前物品重量小于当前容量，有两个选择，装或者不装，取价值最大的<br>
a = dp[i - 1][j - weights[i - 1]] + values[i - 1]; //装入这个物品后的总价值<br>
b = dp[i - 1][j]; //不装<br>
dp[i][j] = Math.max(a,b)<br>
}<br>
}</p>
<pre><code>}
return dp[n][capacity];
</code></pre>
<p>}</p>
<p>不同的二叉搜索树<br>
var numTrees = function(n) {<br>
let dp = new Array(n+1).fill(0);<br>
dp[0] = 1<br>
dp[1] = 1<br>
for (let i = 2; i &lt;= n; ++i) {<br>
for (let j = 1; j &lt;= i; ++j) {<br>
dp[i]  += dp[j-1] * dp[i-j];<br>
}<br>
}<br>
return dp[n]<br>
};</p>
<p>无重复字符的最长子串</p>
<p>var lengthOfLongestSubstring = function(s) {</p>
<pre><code>let max = 0;
let arr = [];
for(let i =0;i&lt;s.length;i++){
    let index = arr.indexOf(s[i]);
    if(index !== -1){
        arr.splice(0,index+1)
    }
    arr.push(s[i]);
    max = Math.max(arr.length,max)
}
return max
</code></pre>
<p>};</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js的小知识点]]></title>
        <id>https://TianhaoXi.github.io/post/js-de-xiao-zhi-shi-dian/</id>
        <link href="https://TianhaoXi.github.io/post/js-de-xiao-zhi-shi-dian/">
        </link>
        <updated>2020-08-16T10:53:11.000Z</updated>
        <content type="html"><![CDATA[<p>变量提升：预先解析代码  var会先声明<br>
使用let 会有临时性死区 需先声明再使用</p>
<p>var 是 globle scope<br>
let const 是 locol scope</p>
<p>匿名函数不会有函数提升 具名函数有函数提升</p>
<p>使用call 和 bind 会立即执行<br>
bind不会立即执行，相当于生成一个新函数</p>
<p>全局函数不会被回收<br>
作用域scope:</p>
<p>每一次调用一个函数就会新开一份内存地址</p>
<p>闭包 读取其他函数内部变量的函数<br>
javascript中，只有函数内部的子函数才能读取局部变量</p>
<p>this指调用函数的对象</p>
<p>object.assign<br>
{...hd}</p>
<p>json prototype:</p>
<p>prototype:<br>
a instanceof b  like: Array object 构造函数<br>
isPrototypeOf  一个object是否是另一个object的prototype<br>
in 会检查自己和prototype chain  hasOwnProperty 只会检查自己的property<br>
继承是prototype的继承，不是constructor的继承</p>
<p>fucntion 可以作为object  <em>proto</em></p>
<p>原型和对象原型</p>
<p>可以用 Symble() 来保护property<br>
pretected = Symble();<br>
this[pretected].name = name;</p>
<p>用WeakMap 保护property<br>
const host = new WeakMap();</p>
<h1 id="private-property">private property</h1>
<p>super是调用parent的方法</p>
<p>regexp<br>
断言匹配:(?= ) 后面是什么<br>
(?&lt;= )前面是什么<br>
(?! ) 后面不是什么<br>
(?&lt;=) 前面不是什么</p>
<p>promise:</p>
<p>new Promise((resolve,reject) =&gt;{<br>
resolve(&quot;yesyes&quot;)<br>
}).then(<br>
value=&gt;{<br>
console.log(&quot;success&quot;)<br>
},<br>
reason =&gt;{<br>
console.log(&quot;failed&quot;)<br>
}<br>
)</p>
<p>宏任务与微任务的顺序</p>
<p>封装ajax:</p>
<p>function</p>
<p>event loop:<br>
一般情况下，一个进程一次只能执行一个任务。</p>
<p>如果有很多任务需要执行，不外乎三种解决方法。</p>
<p>（1）排队。因为一个进程一次只能执行一个任务，只好等前面的任务执行完了，再执行后面的任务。</p>
<p>（2）新建进程。使用fork命令，为每个任务新建一个进程。</p>
<p>（3）新建线程。因为进程太耗费资源，所以如今的程序往往允许一个进程包含多个线程，由线程去完成任务。（进程和线程的详细解释，请看这里。）</p>
<p>JavaScript语言为例，它是一种单线程语言</p>
<p>就是在程序中设置两个线程：一个负责程序本身的运行，称为&quot;主线程&quot;；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为&quot;Event Loop线程&quot;（可以译为&quot;消息线程&quot;）。</p>
<p>js DOM:</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css的小知识点]]></title>
        <id>https://TianhaoXi.github.io/post/css-de-xiao-zhi-shi-dian/</id>
        <link href="https://TianhaoXi.github.io/post/css-de-xiao-zhi-shi-dian/">
        </link>
        <updated>2020-08-16T10:52:47.000Z</updated>
        <content type="html"><![CDATA[<p>4种选择器：. class    # id     p{} type    * all<br>
标签选择器  属性选择器</p>
<p>div&gt;span{}   用&gt;嵌套</p>
<p>width可以有 100%  height只有固定值</p>
<p>background-image: url()<br>
background-repeat<br>
background-size: cover or 100%<br>
background-attachment: fixed | local | scoll</p>
<p>color 最好不要用颜色名称  rgba  a：透明度0-1<br>
opacity 透明度 0-1</p>
<p>text-overflow overflow: hidden</p>
<p>clear float:<br>
在添加float的parent添加一个{clear:left | right | both   overflow: hidden}</p>
<p>visibility: hidden 不可见时依然占位  display:none 不占位</p>
<p>position<br>
relative: left right top bottom</p>
<p>伪类：a: link  a:visited  a:hover  a:active</p>
<p>article :first-child<br>
article: nth-child(2n)</p>
<p>选择器优先级<br>
权重 id:100 class:10 标签:1 *:0 权重是可以叠加的  行级/内联的权重最高</p>
<p>1 选择器优先级内联样式 &gt; ID 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器<br>
强制提高优先级 !important<br>
继承没有权重</p>
<p>字体  1em  = 100%</p>
<p>盒子模型</p>
<p>元素居中： margin-left:auto margin-right:auto<br>
margin 负值 溢出盒子外</p>
<p>box-sizing: border-box  不会管padding 和margin增加的</p>
<p>outline 不会占位  border会</p>
<p>display:none<br>
visibility: hidden<br>
opacity: 0</p>
<p>h2::after{</p>
<p>}</p>
<p>浮动 float<br>
float:left<br>
行级元素 float后会变成块级元素<br>
清除浮动 clear: left||right||both<br>
在浮动元素下追加一个 div class=&quot;clear_fix&quot; 来清除浮动<br>
在父元素后加一个::after<br>
main::after{<br>
clear:both;<br>
display:block;<br>
content:&quot;&quot;<br>
}</p>
<p>或者 在main{<br>
overflow:hidden<br>
}</p>
<p>css定位<br>
relative 相对他在文档中的位置定一个偏移量<br>
如果父级有定位属性，那么下面的定位将参照父级<br>
fix 相对于页面</p>
<p>元素居中的几种方式</p>
<p>flex:<br>
flex-direction<br>
flex-wrap :wrap<br>
justify-content: 对主轴进行排列  center ||  space-between<br>
align-item:</p>
<p>绘制三角形：<br>
section{<br>
width: 0;<br>
height:0;<br>
border-left: 50px solid transparent ;<br>
border-right: 50px solid transparent ;<br>
border-bottom: 50px solid black ;<br>
border-top: 50px solid transparent ;<br>
}</p>
<p>绘制梯形：<br>
section{<br>
width: 100px;<br>
height:0;<br>
border-left: 37px solid transparent ;<br>
border-right: 37px solid transparent ;<br>
border-top: 50px solid red ;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx学习记录]]></title>
        <id>https://TianhaoXi.github.io/post/nginx-xue-xi-ji-lu/</id>
        <link href="https://TianhaoXi.github.io/post/nginx-xue-xi-ji-lu/">
        </link>
        <updated>2020-08-16T10:51:51.000Z</updated>
        <content type="html"><![CDATA[<p>nginx 常用操作<br>
nginx -v 查看版本<br>
service nginx stop 关闭nignx<br>
service nginx start 启动nginx<br>
nginx -s reload 重启nginx</p>
<p>配置文件：<br>
server {<br>
#端口号<br>
listen 80;<br>
#域名或者ip<br>
server_name 112.74.37.77;<br>
#文件的路径<br>
root /www/AlexMain;<br>
#配置默认访问的页面<br>
index index.html;<br>
#配置代理<br>
location /api {<br>
proxy_pass http://127.0.0.1:3033;<br>
}<br>
location /apilist {<br>
rewrite /apilist/(.*) /$1 break;<br>
proxy_pass http://127.0.0.1:3033;<br>
}</p>
<p>location / {<br>
#当输入错误路径时，跳转到index.html页面<br>
try_files $uri $uri/ /index.html;<br>
}<br>
}</p>
<p>nginx全局块： worker_processes auto;   并发数量</p>
<p>event块<br>
events {<br>
worker_connections 1024;<br>
}<br>
nignx 支持的最大连接数</p>
<p>http块：http全局块和server块</p>
<p>location  ~  表示uri 正则表达式 区分大小写<br>
~* 正则表达式 不区分大小写<br>
= 严格匹配</p>
<p>nginx 负载均衡<br>
upstream myserver{}<br>
轮询 ip_hash weight  fair</p>
]]></content>
    </entry>
</feed>