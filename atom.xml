<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://TianhaoXi.github.io</id>
    <title>Alex个人博客</title>
    <updated>2020-09-02T03:42:17.159Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://TianhaoXi.github.io"/>
    <link rel="self" href="https://TianhaoXi.github.io/atom.xml"/>
    <subtitle>学习，分享，进步</subtitle>
    <logo>https://TianhaoXi.github.io/images/avatar.png</logo>
    <icon>https://TianhaoXi.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Alex个人博客</rights>
    <entry>
        <title type="html"><![CDATA[jd 面试]]></title>
        <id>https://TianhaoXi.github.io/post/jd-mian-shi/</id>
        <link href="https://TianhaoXi.github.io/post/jd-mian-shi/">
        </link>
        <updated>2020-09-01T09:14:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="css-position有几种属性">CSS position有几种属性</h1>
<p>position: static; 的元素不会被特殊的定位<br>
fixed：元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动，相当一个壁纸标签一样一动不动像镶嵌在屏幕里一样，<br>
相对定位，是相对于其原本的位置来定位的。元素仍处于文档流中，定位是相对于原本自身的位置<br>
absolute：元素会脱离文档流，定位是相对于离它最近的且不是static定位的父元素而言，若该元素没有设置宽度，则宽度由元素里面的内容决定，且宽度不会影响父元素，定位为absolution后，原来的位置相当于是空的，下面的的元素会来占据。<br>
sticky：<br>
必须制定 top、bottom 、left 、 right 4个值之一，否则只会处于相对定位；<br>
父元素的高度不能低于sticky 元素的高度；<br>
sticky 元素仅在其父元素内生效；</p>
<p>for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用for-in循环</p>
<p>标准盒模型 box-sizing: content-box<br>
content-box:<br>
width = content width;<br>
height = content height</p>
<p>IE盒模型 box-sizing: border-box<br>
border-box:<br>
width = border + padding + content width<br>
heigth = border + padding + content heigth</p>
<p>赋值方法 （Mutator methods）<br>
pop 和 push shift 和 unshift splice reverse sort<br>
访问方法（Accessor methods）：<br>
join slice concat</p>
<p>迭代方法（Iteration methods）<br>
forEach forEach是无法通过break来中断数组的遍历。<br>
map</p>
<p>由于继承而发生样式冲突时，最近祖先获胜（最近原则）。<br>
继承的样式和直接指定的样式冲突时，直接指定的样式获胜（最直接原则）。<br>
直接指定的样式发生冲突时，样式权值高者获胜。<br>
css选择器 权值<br>
标签选择器 1<br>
类选择器 10<br>
ID选择器 100<br>
内联样式 1000<br>
伪元素(:first-child等) 1<br>
伪类(:link等) 10<br>
可以看到，内联样式的权值&gt;&gt;ID选择器&gt;&gt;类选择器&gt;&gt;标签选择器，除此以外，后代选择器的权值为每项权值之和，比如”<br>
样式权值相同时，后者获胜。<br>
!important的样式属性不被覆盖。</p>
<h1 id="事件委托">事件委托</h1>
<p>window.onload = function(){<br>
　　var oUl = document.getElementById(&quot;ul1&quot;);<br>
　　oUl.onclick = function(ev){<br>
　　　　var ev = ev || window.event;<br>
　　　　var target = ev.target || ev.srcElement;<br>
　　　　if(target.nodeName.toLowerCase() == 'li'){<br>
　 　　　　　　 alert(123);<br>
　　　　　　　  alert(target.innerHTML);<br>
　　　　}<br>
　　}<br>
}</p>
<h1 id="判断数据类型">判断数据类型</h1>
<p>使用typeof操作符。<br>
　　对一个值使用 typeof 操作符可能返回下列某个字符串，返回的类型都是字符串形式。</p>
<p>(1) undefined：如果这个值未定义</p>
<p>(2) boolean：如果这个值是布尔值</p>
<p>(3) string：如果这个值是字符串</p>
<p>(4) number：如果这个值是数值</p>
<p>(5) object：如果这个值是对象或null</p>
<p>(6) function：如果这个值是函数</p>
<p>需要注意：typeof不适合用于判断是否为数组。当使用typeof判断数组和对象的时候，都会返回object。</p>
<p>instanceof<br>
　　instanceof 运算符用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上。需要区分大小写。</p>
<p>简单的来说，instanceof 用于判断一个变量是否某个对象的实例。</p>
<p>例：var arr = new Array( );</p>
<p>alert(arr instanceof Array);   // 返回true</p>
<p>需要注意的是，instanceof只能用来判断对象和函数，不能用来判断字符串和数字等。判断它是否为字符串和数字时，只会返回false。</p>
<p>constructor 属性返回对创建此对象的数组函数的引用。</p>
<p>在JavaScript中，每个具有原型的对象都会自动获得constructor属性。</p>
<p>Object.prototype.toString.call</p>
<p>时效缓存（强制缓存）：<br>
Cache-Control （低版本浏览器用的是Expires，了解即可）</p>
<p>是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。</p>
<p>private:             客户端可以缓存</p>
<p>public:              客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）</p>
<p>max-age=xxx:   缓存的内容将在 xxx 秒后失效</p>
<p>no-cache:          需要使用对比缓存来验证缓存数据</p>
<p>no-store:           所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so...基本上和它说886）</p>
<p>非时效缓存（对比缓存，用的是标识）：<br>
他用的不是时效时间max-age</p>
<p>第一次请求的时候，返回给客户端数据和缓存的信息，也就是一个特定的缓存标识</p>
<p>客户端把这个缓存标识放到缓存数据库</p>
<p>再次请求时 客户端先把缓存标识也一起发给服务端，进行对比</p>
<p>客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。</p>
<p>分为两种缓存标识</p>
<p>Etag （唯一标识）优先级更高</p>
<p>Last-Modified/If-Modified-Since  返回给客户端最后这个资源的修改时间，优先级没有Etag高</p>
<p>对比缓存标识生效不生效时，状态码200，服务端返回body和header</p>
<p>在对比缓存标识生效时，状态码为304，并且报文大小和请求时间大大减少。</p>
<p>原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。强制缓存的优先级更高，如果没失效，就直接用缓存数据库里的东西</p>
<p>如果时间已经失效了，就看用的是哪种标识（Etag服务端生成的唯一标识，还是last-modified资源最后修改时间标识）返回304就用缓存里的，返回200就返回body和新的header</p>
<p>一般来说，无论如何都会协商缓存，浏览器必备的缓存不可能没有~</p>
<p>1.3 前端性能优化的方法？<br>
（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</p>
<p>（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</p>
<p>（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</p>
<p>（4） 当需要设置的样式很多时设置className而不是直接操作style。</p>
<p>（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</p>
<p>（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</p>
<p>（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。</p>
<p>（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。</p>
<p>css常见块元素行元素及其区别<br>
答： 块 div p h1-6 hr li ul<br>
行 a img input span  br<br>
块级元素单独占一行，行元素多个占一行<br>
块级元素可以设置宽高，行元素不行<br>
行元素上下外边距内边距无效</p>
<p>css3用过哪些<br>
边框圆角、动画、transfrom</p>
<p>cookie的作用及字段属性干啥的<br>
作为一种标记，可以储存用户信息。<br>
name 名字值  expires 过期时间 path 可以访问此cookie的路径  domain 可以访问此cookie的域 httponly 是否只能通过http获取  secure 是否只通过https发送  samesite cookie是否跨站</p>
<p>.es6新特性<br>
let const 、箭头函数、map、set、...、class、promise</p>
<p>浅复制，assign，{...}<br>
12.深复制，loadsh库deepclone，json.parse(json.stringify)</p>
<p>利用id获取就是：document.getElementById(&quot;name&quot;);</p>
<p>利用class获取就是：document.getElementsByClassName(&quot;name&quot;);</p>
<p>利用标签获取就是：document.getElementsByClassTagName(&quot;name&quot;)；<br>
创建新元素，追加到已有的元素上：document.getElementById(&quot;name&quot;).createElement(“”);<br>
document.documentElement.clientWidth--获取宽度<br>
document.documentElement.clientHeight--获取高度</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
<p>箭头函数是匿名函数，不能作为构造函数，不能使用new<br>
箭头函数不能绑定arguments，取而代之用rest参数...解决</p>
<p>箭头函数的this永远指向其上下文的this，没有办改变其指向，<br>
普通函数的this指向调用它的对象<br>
箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值</p>
<p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。同名属性会替换。<br>
Object.create(prototype[,propertiesObject])<br>
Object.defineProperties(obj,props)<br>
Object.keys(obj)<br>
Object.values()<br>
Object.entries()</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Promise 并发限制]]></title>
        <id>https://TianhaoXi.github.io/post/promise-bing-fa-xian-zhi/</id>
        <link href="https://TianhaoXi.github.io/post/promise-bing-fa-xian-zhi/">
        </link>
        <updated>2020-08-31T02:50:13.000Z</updated>
        <content type="html"><![CDATA[<p>function asyncPool(poolLimit, array, iteratorFn) {<br>
let i = 0;<br>
const ret = [];<br>
const executing = [];<br>
const enqueue = function () {<br>
// 边界处理，array为空数组<br>
if (i === array.length) {<br>
return Promise.resolve();<br>
}<br>
// 每调一次enqueue，初始化一个promise<br>
const item = array[i++];<br>
const p = Promise.resolve().then(() =&gt; iteratorFn(item, array));<br>
// 放入promises数组<br>
ret.push(p);<br>
// promise执行完毕，从executing数组中删除<br>
const e = p.then(() =&gt; executing.splice(executing.indexOf(e), 1));<br>
// 插入executing数字，表示正在执行的promise<br>
executing.push(e);<br>
// 使用Promise.rece，每当executing数组中promise数量低于poolLimit，就实例化新的promise并执行<br>
let r = Promise.resolve();<br>
if (executing.length &gt;= poolLimit) {<br>
r = Promise.race(executing);<br>
}<br>
// 递归，直到遍历完array<br>
return r.then(() =&gt; enqueue());<br>
};<br>
return enqueue().then(() =&gt; Promise.all(ret));<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[各种排序]]></title>
        <id>https://TianhaoXi.github.io/post/ge-chong-pai-xu/</id>
        <link href="https://TianhaoXi.github.io/post/ge-chong-pai-xu/">
        </link>
        <updated>2020-08-29T00:30:02.000Z</updated>
        <content type="html"><![CDATA[<p>// 遍历一遍</p>
<p>// 二分查找  iteration<br>
function binary_search(array,key){<br>
var low = 0;<br>
var high = array.length -1;</p>
<pre><code>while(low &lt;=high){
    var mid = Math.floor((low+high)/2)
    if(array[mid] ==key){
        return mid
    }
    else if(array[mid]&lt;key){
        low = mid+1
    }
    else if(array[mid]&gt;key){
        high = mid-1
    }
    else{
        return -1
    }
}
</code></pre>
<p>}</p>
<p>// Bubble sort</p>
<p>function swap(obj, a, b) { var tmp = obj[a]; obj[a] = obj[b]; obj[b] = tmp; }</p>
<p>function bubbleSort(arr) {<br>
let len = arr.length;</p>
<p>for (let i = 0; i &lt; len; i++) {<br>
for (let j = 0; j &lt; len - i - 1; j++) {<br>
if (arr[j] &gt; arr[j + 1]) {  // 相邻元素两两对比<br>
swap(array,j,j+1)<br>
}<br>
}<br>
}</p>
<p>return arr;<br>
}</p>
<p>var array = [3,5,1,2,3,5,6,7]<br>
var result = bubbleSort(array);<br>
console.log(result)</p>
<p>// selection sort</p>
<p>function swap(obj, a, b) { var tmp = obj[a]; obj[a] = obj[b]; obj[b] = tmp; }</p>
<p>function selection_sort(array){<br>
var len = array.length<br>
if(array==null || array.length&lt;=2){<br>
return array<br>
}</p>
<pre><code>for (let i = 0; i &lt; len; i++) {
    var min = i
    for (let j = i+1; j &lt; len; j++) {
        if(array[j]&lt;array[min]){
            min =j
        }
    }
              swap(array,i,min)

}
</code></pre>
<p>}<br>
var array = [3,5,1,2,3,5,6,7]<br>
var result = selection_sort(array);<br>
console.log(array)</p>
<p>//insertion sort</p>
<p>function insertion_sort(arr){<br>
for (var i = 1, length = arr.length; i &lt; length; i++) {<br>
var key = arr[i];<br>
var j = i - 1;<br>
while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {<br>
arr[j + 1] = arr[j];<br>
j--;<br>
}<br>
arr[j + 1] = key;<br>
}<br>
return arr;</p>
<p>}<br>
var array = [3,5,1,2,3,5,6,7]<br>
var result = insertion_sort(array);<br>
console.log(result)</p>
<p>// merge Sort<br>
function mergeSort(arr) { // 采用自上而下的递归方法<br>
var length = arr.length;<br>
if (length &lt; 2) {<br>
return arr;<br>
}</p>
<pre><code>var middle = Math.floor(length / 2);
var left = arr.slice(0, middle);
var right = arr.slice(middle);

return merge(mergeSort(left), mergeSort(right));
</code></pre>
<p>}</p>
<p>function merge(left, right) {<br>
var result = [];<br>
console.log('left', left, 'right', right);<br>
while (left.length &amp;&amp; right.length) {<br>
if (left[0] &lt;= right[0]) {<br>
result.push(left.shift());<br>
} else {<br>
result.push(right.shift());<br>
}<br>
}</p>
<pre><code>while (left.length) {
  result.push(left.shift());
}

while (right.length) {
  result.push(right.shift());
}
return result;
</code></pre>
<p>}</p>
<p>var array = [3,5,1,2,3,5,6,7]<br>
var result = mergeSort(array);<br>
console.log(result)</p>
<p>//  对数器</p>
<p>//要测试的方法<br>
function insertSort(arr) {<br>
for (let i = 1; i &lt; arr.length; i++) {<br>
for (let j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) {<br>
[arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];<br>
}<br>
}<br>
}<br>
//正确的方法<br>
function rightMethod(arr) {<br>
arr.sort((a, b)=&gt;a - b);<br>
}<br>
//随机数组生成器，size为最大长度，value为最大值<br>
function generateRandomArray(size, value) {<br>
//生成长度随机的数组<br>
let arr = new Array(Math.floor((size + 1) * Math.random()));<br>
for (let i = 0; i &lt; arr.length; i++) {<br>
arr[i] = Math.floor((value + 1) * Math.random());<br>
}<br>
return arr;<br>
}<br>
//拷贝数组方法<br>
function copyArray(arr) {<br>
if (arr == null) {<br>
return null;<br>
}<br>
return [].concat(arr);<br>
}<br>
//比对方法<br>
function isEqual(arr1, arr2) {<br>
if ((arr1 == null &amp;&amp; arr2 != null ) || (arr1 != null &amp;&amp; arr2 == null)) {<br>
return false;<br>
}<br>
if (arr1 == null &amp;&amp; arr2 == null) {<br>
return true;<br>
}<br>
if (arr1.length != arr2.length) {<br>
return false;<br>
}<br>
for (let i = 0; i &lt; arr1.length; i++) {<br>
if (arr1[i] != arr2[i]) {<br>
return false<br>
}<br>
}<br>
return true;<br>
}<br>
//测试<br>
function Test() {<br>
let testTimes = 5000;<br>
let size = 10;<br>
let value = 100;<br>
let succeed = true;<br>
for (let i = 0; i &lt; testTimes; i++) {<br>
let arr1 = generateRandomArray(size, value);<br>
let arr2 = copyArray(arr1);<br>
let arr3 = copyArray(arr1);<br>
insertSort(arr1);<br>
rightMethod(arr2);<br>
if (!isEqual(arr1, arr2)) {<br>
succeed = false;<br>
console.log(arr3);<br>
break;<br>
}<br>
}<br>
console.log(succeed ? &quot;nice&quot; : &quot;Fucking fucked&quot;);<br>
}<br>
Test();</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[寻找document全部节点]]></title>
        <id>https://TianhaoXi.github.io/post/xun-zhao-document-quan-bu-jie-dian/</id>
        <link href="https://TianhaoXi.github.io/post/xun-zhao-document-quan-bu-jie-dian/">
        </link>
        <updated>2020-08-28T07:33:31.000Z</updated>
        <content type="html"><![CDATA[<p>function getElCount(n){                     //定义文档元素统计函数<br>
var num = 0;                            //初始化变量<br>
if(n.nodeType == 1){                    //检查是否为元素节点<br>
num++;                              //如果是，计数器加1<br>
console.log(n.nodeName);            //输出元素节点名称<br>
}<br>
var son = n.childNodes;                 //获取所有子节点<br>
for(var i=0 ; i&lt;son.length ; i++){      //遍历每个子元素<br>
num += getElCount(son[i]);    //递归操作<br>
}<br>
return num;                             //返回统计值<br>
}<br>
window.onload=function(){<br>
console.log('文档中元素节点的个数是：'+getElCount(document)+'个')<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[全排列]]></title>
        <id>https://TianhaoXi.github.io/post/quan-pai-lie/</id>
        <link href="https://TianhaoXi.github.io/post/quan-pai-lie/">
        </link>
        <updated>2020-08-22T12:03:05.000Z</updated>
        <content type="html"><![CDATA[<p>var permute = function(nums) {<br>
const list = [];<br>
backtrack(list, [], nums)<br>
return list<br>
};</p>
<p>function backtrack(list,templist,num){<br>
if(templist.length === num.length){<br>
list.push([...templist])<br>
}<br>
for(let i=0;i&lt;num.length;i++){<br>
if(templist.includes(num[i])){<br>
continue;<br>
}<br>
templist.push(num[i]);<br>
backtrack(list,templist,num);<br>
templist.pop()<br>
}<br>
}</p>
<p>var permute = function(nums) {<br>
let n = nums.length;<br>
nums = nums.sort((a,b) =&gt; {return a - b});<br>
let res = [];<br>
let tmpPath = [];<br>
let hash = {};<br>
let backtrack = (tmpPath) =&gt; {<br>
if(tmpPath.length == n){<br>
res.push(tmpPath);<br>
return;<br>
}<br>
for(let i = 0;i &lt; n;i++){<br>
if(hash[i] || (i &gt; 0 &amp;&amp; !hash[i-1] &amp;&amp; nums[i-1] == nums[i])) continue;<br>
hash[i] = true;<br>
tmpPath.push(nums[i]);<br>
backtrack([...tmpPath]);<br>
hash[i] = false;<br>
tmpPath.pop();<br>
}<br>
}<br>
backtrack(tmpPath);<br>
return res;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[merge sort]]></title>
        <id>https://TianhaoXi.github.io/post/merge-sort/</id>
        <link href="https://TianhaoXi.github.io/post/merge-sort/">
        </link>
        <updated>2020-08-22T08:06:15.000Z</updated>
        <content type="html"><![CDATA[<p>// merge Sort<br>
function mergeSort(arr) { // 采用自上而下的递归方法<br>
var length = arr.length;<br>
if (length &lt; 2) {<br>
return arr;<br>
}</p>
<pre><code>var middle = Math.floor(length / 2);
var left = arr.slice(0, middle);
var right = arr.slice(middle);

return merge(mergeSort(left), mergeSort(right));
</code></pre>
<p>}</p>
<p>function merge(left, right) {<br>
var result = [];<br>
console.log('left', left, 'right', right);<br>
while (left.length &amp;&amp; right.length) {<br>
if (left[0] &lt;= right[0]) {<br>
result.push(left.shift());<br>
} else {<br>
result.push(right.shift());<br>
}<br>
}</p>
<pre><code>while (left.length) {
  result.push(left.shift());
}

while (right.length) {
  result.push(right.shift());
}
return result;
</code></pre>
<p>}</p>
<p>var array = [3,5,1,2,3,5,6,7]<br>
var result = mergeSort(array);<br>
console.log(result)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[matrix_clodckspin]]></title>
        <id>https://TianhaoXi.github.io/post/matrix_clodckspin/</id>
        <link href="https://TianhaoXi.github.io/post/matrix_clodckspin/">
        </link>
        <updated>2020-08-22T08:04:52.000Z</updated>
        <content type="html"><![CDATA[<p>function printMatrix(matrix)<br>
{<br>
// write code here</p>
<pre><code>var row = matrix.length;
var col = matrix[0].length;
   

var res = [];
if(row ==0 || col == 0){
    return null;
}

var left = 0; var right = col - 1; var top=0; var bottom = row-1;

while(left&lt;= right &amp;&amp; top &lt;= bottom ){
    
    for(var i =left; i&lt;= right; i++){
        res.push(matrix[top][i]);
    }
    for(var i = top+1; i&lt;= bottom;i++ ){
        res.push(matrix[i][right]);
    }
    if(top != bottom){
        for (var i = right-1;i&gt;= left;i--){
            res.push(matrix[bottom][i]);
        }
    }
    if(left != right){
        for (var i = bottom-1 ; i&gt; top;i--){
            res.push(matrix[i][left]);
        }
    }
  left = left+1;  
  top = top+1;
  right = right -1;
   bottom = bottom -1; 
}
return res;
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quick sort]]></title>
        <id>https://TianhaoXi.github.io/post/quick-sort/</id>
        <link href="https://TianhaoXi.github.io/post/quick-sort/">
        </link>
        <updated>2020-08-22T08:04:33.000Z</updated>
        <content type="html"><![CDATA[<p>// quick sort</p>
<p>function quicksort(array){<br>
if(array.length&lt;2){<br>
return array;<br>
}</p>
<pre><code>var piviotindex = Math.floor(array.length/2)
var pivot = array.splice(piviotindex,1)[0];
var left =[];
var right = [];

for(var i =0;i&lt;array.length;i++){
    if(array[i]&lt;pivot){
        left.push(array[i])
    }
    else{
        right.push(array[i])
    }
}

return quicksort(left).concat([pivot],quicksort(right))
</code></pre>
<p>}</p>
<p>////////////////////<br>
function quickSort(arr, left, right) {<br>
if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof length === 'number' &amp;&amp; typeof right === 'number') {</p>
<pre><code>  if (left &lt; right) {
    var pivot = arr[left]; // 起始位置
    var setPos = left + 1; // 设置的位置
    for (var i = left + 1; i &lt;= right; i++) {
      if (arr[i] &lt; pivot) {
        swap(arr,i,setPos)
        setPos++;
      }
    }
    // 循环完成之后将key与 pos-1的位置交换
    swap(arr,left,setPos-1)

    // console.log('每一次排序', '当前key值===&gt;', key, '排序完成当前数组===&gt;', JSON.stringify(arr));

    quickSort(arr, left, setPos - 2);
    quickSort(arr, setPos, right);
    // console.log('arr=======&gt;', arr);
  }
} else {
  return 'array is not an Array or left or right is not a number!';
}
return arr;
</code></pre>
<p>}</p>
<p>function swap(obj, a, b) { var tmp = obj[a]; obj[a] = obj[b]; obj[b] = tmp; }</p>
<p>var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];<br>
// var arr = [7, 3, 2, 10, 13, 8, 5];<br>
console.log(quickSort(arr, 0, arr.length - 1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Heap sort]]></title>
        <id>https://TianhaoXi.github.io/post/heap-sort/</id>
        <link href="https://TianhaoXi.github.io/post/heap-sort/">
        </link>
        <updated>2020-08-22T08:02:40.000Z</updated>
        <content type="html"><![CDATA[<p>function swap(obj, a, b) { var tmp = obj[a]; obj[a] = obj[b]; obj[b] = tmp; }</p>
<p>function bubbleup(array,index){<br>
const parentindex = Math.floor((index-1)/2)<br>
if(array[parentindex] &amp;&amp; array[parentindex]&lt;array[index]){<br>
swap(array,parentindex,index)<br>
bubbleup(array,parentindex);<br>
}<br>
return;<br>
}</p>
<p>function bubbledown(arr,index,size){<br>
var left = index * 2 + 1;<br>
while (left &lt; size) {<br>
var largest = left + 1 &lt; size &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;<br>
largest = arr[largest] &gt; arr[index] ? largest : index;<br>
if (largest == index) {<br>
break;<br>
}<br>
swap(arr, largest, index);<br>
index = largest;<br>
left = index * 2 + 1;<br>
}<br>
}</p>
<p>function heapSort(arr) {<br>
if (arr == null || arr.length &lt; 2) {<br>
return;<br>
}</p>
<pre><code>for (var i = 0; i &lt; arr.length; i++) {
    bubbleup(arr, i);
}
var size = arr.length;
swap(arr, 0, --size);
while (size &gt; 0) {
    bubbledown(arr, 0, size);
    swap(arr, 0, --size);
}
</code></pre>
<p>}</p>
<p>var arr = [91, 60, 96, 13, 35, 65, 46, 65, 10, 30, 20, 31, 77, 81, 22];<br>
heapSort(arr);<br>
console.log(arr)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划常见题]]></title>
        <id>https://TianhaoXi.github.io/post/dong-tai-gui-hua-chang-jian-ti/</id>
        <link href="https://TianhaoXi.github.io/post/dong-tai-gui-hua-chang-jian-ti/">
        </link>
        <updated>2020-08-22T03:25:36.000Z</updated>
        <content type="html"><![CDATA[<p>代金券组合😎dp<br>
function coinChange(coins,amount){<br>
let dp = new Array(amount+1).fill(Infinity)<br>
dp[0]=0;<br>
for(let coin of coins){<br>
for(let i =1;i&lt;=amount;i++){<br>
if(i-coin&gt;=0){<br>
dp[i]=Math.min(dp[i],dp[i-coin]+1)<br>
}<br>
}<br>
}</p>
<pre><code>return dp[amount] === Infinity ? 'Impossible' : dp[amount];
</code></pre>
<p>}</p>
<p>最小路径和：<br>
function minPath(grid){<br>
let m = grid.length;<br>
let n = grid[0].length;</p>
<pre><code>for(let i =m-1;i&gt;=0;i--){
    for(let j=n-1;j&gt;=0;j--){
        if (i + 1 &lt; m &amp;&amp; j + 1 &lt; n) {
            grid[i][j] += Math.min(grid[i + 1][j], grid[i][j + 1])
        } else if (i + 1 &lt; m) {
            grid[i][j] += grid[i + 1][j]
        } else if (j + 1 &lt; n) {
            grid[i][j] += grid[i][j + 1]
        }
    }
}
return grid[0][0];   
</code></pre>
<p>}</p>
<p>01 背包<br>
var line=readline().split(' ');<br>
var N=parseInt(line[0]);//承重<br>
var c=parseInt(line[1]);//数量<br>
var w=[0],p=[0];//重 价值<br>
while(lines=readline()){<br>
let nums=lines.split(' ').map(Number);<br>
p.push(nums[0])//;<br>
w.push(nums[1]);<br>
}<br>
function DyadicArray(N, c, w, p) {<br>
//初始化表格<br>
var dp = new Array(N + 1); //表格有n+1行<br>
for (let n = 0; n &lt; N + 1; n++) {<br>
dp[n] = new Array(c + 1).fill(0); //每行有c+1列<br>
}</p>
<p>for (let i = 1; i &lt;= N; i++) {<br>
for (let j = 0; j &lt;= c; j++) {<br>
if (j - w[i] &gt;= 0) {<br>
dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w[i]] + p[i]);<br>
} else {<br>
dp[i][j] = dp[i - 1][j];<br>
}<br>
}<br>
}<br>
return(dp[N][c])<br>
}<br>
console.log(DyadicArray(N, c, w, p))</p>
<p>最长公共子序列</p>
<p>var longestCommonSubsequence = function(text1, text2) {<br>
let n = text1.length;<br>
let m = text2.length;<br>
let dp = Array.from(new Array(n+1),() =&gt; new Array(m+1).fill(0));</p>
<pre><code>for(let i =1;i&lt;=n;i++){
    for(let j=1;j&lt;=m;j++){
        if(text1[i-1]===text2[j-1]){
            dp[i][j] = 1+dp[i-1][j-1];
        }
        else{
            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])
        }
    }
}
return dp[n][m]
</code></pre>
<p>};</p>
<p>01 背包：<br>
function kanpSack(capacity, weights, values, n) {<br>
var a,b,dp = []</p>
<p>//首先，初始化用于寻找解决方案的矩阵KS[n+1][capacity+1]<br>
for (var i = 0; i &lt;= n; i++) {<br>
dp[i] = [];<br>
}<br>
for (var i = 0; i &lt;= n; i++) {<br>
for (var j = 0; j &lt;= capacity; j++) {<br>
if (i === 0 || j === 0) {<br>
//让第一行和第一列为0，因为第一行和第一列表示容量为0或没有物品可装<br>
dp[i][j] = 0;<br>
} else if (weights[i - 1] &gt; j) {<br>
dp[i][j] = dp[i - 1][j]; //当前物品重量大于当前容量<br>
} else {<br>
//当前物品重量小于当前容量，有两个选择，装或者不装，取价值最大的<br>
a = dp[i - 1][j - weights[i - 1]] + values[i - 1]; //装入这个物品后的总价值<br>
b = dp[i - 1][j]; //不装<br>
dp[i][j] = Math.max(a,b)<br>
}<br>
}</p>
<pre><code>}
return dp[n][capacity];
</code></pre>
<p>}</p>
<p>不同的二叉搜索树<br>
var numTrees = function(n) {<br>
let dp = new Array(n+1).fill(0);<br>
dp[0] = 1<br>
dp[1] = 1<br>
for (let i = 2; i &lt;= n; ++i) {<br>
for (let j = 1; j &lt;= i; ++j) {<br>
dp[i]  += dp[j-1] * dp[i-j];<br>
}<br>
}<br>
return dp[n]<br>
};</p>
<p>无重复字符的最长子串</p>
<p>var lengthOfLongestSubstring = function(s) {</p>
<pre><code>let max = 0;
let arr = [];
for(let i =0;i&lt;s.length;i++){
    let index = arr.indexOf(s[i]);
    if(index !== -1){
        arr.splice(0,index+1)
    }
    arr.push(s[i]);
    max = Math.max(arr.length,max)
}
return max
</code></pre>
<p>};</p>
]]></content>
    </entry>
</feed>