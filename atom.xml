<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://TianhaoXi.github.io</id>
    <title>Alex个人博客</title>
    <updated>2020-09-01T05:36:57.593Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://TianhaoXi.github.io"/>
    <link rel="self" href="https://TianhaoXi.github.io/atom.xml"/>
    <subtitle>学习，分享，进步</subtitle>
    <logo>https://TianhaoXi.github.io/images/avatar.png</logo>
    <icon>https://TianhaoXi.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Alex个人博客</rights>
    <entry>
        <title type="html"><![CDATA[Promise 并发限制]]></title>
        <id>https://TianhaoXi.github.io/post/promise-bing-fa-xian-zhi/</id>
        <link href="https://TianhaoXi.github.io/post/promise-bing-fa-xian-zhi/">
        </link>
        <updated>2020-08-31T02:50:13.000Z</updated>
        <content type="html"><![CDATA[<p>function asyncPool(poolLimit, array, iteratorFn) {<br>
let i = 0;<br>
const ret = [];<br>
const executing = [];<br>
const enqueue = function () {<br>
// 边界处理，array为空数组<br>
if (i === array.length) {<br>
return Promise.resolve();<br>
}<br>
// 每调一次enqueue，初始化一个promise<br>
const item = array[i++];<br>
const p = Promise.resolve().then(() =&gt; iteratorFn(item, array));<br>
// 放入promises数组<br>
ret.push(p);<br>
// promise执行完毕，从executing数组中删除<br>
const e = p.then(() =&gt; executing.splice(executing.indexOf(e), 1));<br>
// 插入executing数字，表示正在执行的promise<br>
executing.push(e);<br>
// 使用Promise.rece，每当executing数组中promise数量低于poolLimit，就实例化新的promise并执行<br>
let r = Promise.resolve();<br>
if (executing.length &gt;= poolLimit) {<br>
r = Promise.race(executing);<br>
}<br>
// 递归，直到遍历完array<br>
return r.then(() =&gt; enqueue());<br>
};<br>
return enqueue().then(() =&gt; Promise.all(ret));<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[各种排序]]></title>
        <id>https://TianhaoXi.github.io/post/ge-chong-pai-xu/</id>
        <link href="https://TianhaoXi.github.io/post/ge-chong-pai-xu/">
        </link>
        <updated>2020-08-29T00:30:02.000Z</updated>
        <content type="html"><![CDATA[<p>// 遍历一遍</p>
<p>// 二分查找  iteration<br>
function binary_search(array,key){<br>
var low = 0;<br>
var high = array.length -1;</p>
<pre><code>while(low &lt;=high){
    var mid = Math.floor((low+high)/2)
    if(array[mid] ==key){
        return mid
    }
    else if(array[mid]&lt;key){
        low = mid+1
    }
    else if(array[mid]&gt;key){
        high = mid-1
    }
    else{
        return -1
    }
}
</code></pre>
<p>}</p>
<p>// Bubble sort</p>
<p>function swap(obj, a, b) { var tmp = obj[a]; obj[a] = obj[b]; obj[b] = tmp; }</p>
<p>function bubbleSort(arr) {<br>
let len = arr.length;</p>
<p>for (let i = 0; i &lt; len; i++) {<br>
for (let j = 0; j &lt; len - i - 1; j++) {<br>
if (arr[j] &gt; arr[j + 1]) {  // 相邻元素两两对比<br>
swap(array,j,j+1)<br>
}<br>
}<br>
}</p>
<p>return arr;<br>
}</p>
<p>var array = [3,5,1,2,3,5,6,7]<br>
var result = bubbleSort(array);<br>
console.log(result)</p>
<p>// selection sort</p>
<p>function swap(obj, a, b) { var tmp = obj[a]; obj[a] = obj[b]; obj[b] = tmp; }</p>
<p>function selection_sort(array){<br>
var len = array.length<br>
if(array==null || array.length&lt;=2){<br>
return array<br>
}</p>
<pre><code>for (let i = 0; i &lt; len; i++) {
    var min = i
    for (let j = i+1; j &lt; len; j++) {
        if(array[j]&lt;array[min]){
            min =j
        }
    }
              swap(array,i,min)

}
</code></pre>
<p>}<br>
var array = [3,5,1,2,3,5,6,7]<br>
var result = selection_sort(array);<br>
console.log(array)</p>
<p>//insertion sort</p>
<p>function insertion_sort(arr){<br>
for (var i = 1, length = arr.length; i &lt; length; i++) {<br>
var key = arr[i];<br>
var j = i - 1;<br>
while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {<br>
arr[j + 1] = arr[j];<br>
j--;<br>
}<br>
arr[j + 1] = key;<br>
}<br>
return arr;</p>
<p>}<br>
var array = [3,5,1,2,3,5,6,7]<br>
var result = insertion_sort(array);<br>
console.log(result)</p>
<p>// merge Sort<br>
function mergeSort(arr) { // 采用自上而下的递归方法<br>
var length = arr.length;<br>
if (length &lt; 2) {<br>
return arr;<br>
}</p>
<pre><code>var middle = Math.floor(length / 2);
var left = arr.slice(0, middle);
var right = arr.slice(middle);

return merge(mergeSort(left), mergeSort(right));
</code></pre>
<p>}</p>
<p>function merge(left, right) {<br>
var result = [];<br>
console.log('left', left, 'right', right);<br>
while (left.length &amp;&amp; right.length) {<br>
if (left[0] &lt;= right[0]) {<br>
result.push(left.shift());<br>
} else {<br>
result.push(right.shift());<br>
}<br>
}</p>
<pre><code>while (left.length) {
  result.push(left.shift());
}

while (right.length) {
  result.push(right.shift());
}
return result;
</code></pre>
<p>}</p>
<p>var array = [3,5,1,2,3,5,6,7]<br>
var result = mergeSort(array);<br>
console.log(result)</p>
<p>//  对数器</p>
<p>//要测试的方法<br>
function insertSort(arr) {<br>
for (let i = 1; i &lt; arr.length; i++) {<br>
for (let j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) {<br>
[arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];<br>
}<br>
}<br>
}<br>
//正确的方法<br>
function rightMethod(arr) {<br>
arr.sort((a, b)=&gt;a - b);<br>
}<br>
//随机数组生成器，size为最大长度，value为最大值<br>
function generateRandomArray(size, value) {<br>
//生成长度随机的数组<br>
let arr = new Array(Math.floor((size + 1) * Math.random()));<br>
for (let i = 0; i &lt; arr.length; i++) {<br>
arr[i] = Math.floor((value + 1) * Math.random());<br>
}<br>
return arr;<br>
}<br>
//拷贝数组方法<br>
function copyArray(arr) {<br>
if (arr == null) {<br>
return null;<br>
}<br>
return [].concat(arr);<br>
}<br>
//比对方法<br>
function isEqual(arr1, arr2) {<br>
if ((arr1 == null &amp;&amp; arr2 != null ) || (arr1 != null &amp;&amp; arr2 == null)) {<br>
return false;<br>
}<br>
if (arr1 == null &amp;&amp; arr2 == null) {<br>
return true;<br>
}<br>
if (arr1.length != arr2.length) {<br>
return false;<br>
}<br>
for (let i = 0; i &lt; arr1.length; i++) {<br>
if (arr1[i] != arr2[i]) {<br>
return false<br>
}<br>
}<br>
return true;<br>
}<br>
//测试<br>
function Test() {<br>
let testTimes = 5000;<br>
let size = 10;<br>
let value = 100;<br>
let succeed = true;<br>
for (let i = 0; i &lt; testTimes; i++) {<br>
let arr1 = generateRandomArray(size, value);<br>
let arr2 = copyArray(arr1);<br>
let arr3 = copyArray(arr1);<br>
insertSort(arr1);<br>
rightMethod(arr2);<br>
if (!isEqual(arr1, arr2)) {<br>
succeed = false;<br>
console.log(arr3);<br>
break;<br>
}<br>
}<br>
console.log(succeed ? &quot;nice&quot; : &quot;Fucking fucked&quot;);<br>
}<br>
Test();</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[寻找document全部节点]]></title>
        <id>https://TianhaoXi.github.io/post/xun-zhao-document-quan-bu-jie-dian/</id>
        <link href="https://TianhaoXi.github.io/post/xun-zhao-document-quan-bu-jie-dian/">
        </link>
        <updated>2020-08-28T07:33:31.000Z</updated>
        <content type="html"><![CDATA[<p>function getElCount(n){                     //定义文档元素统计函数<br>
var num = 0;                            //初始化变量<br>
if(n.nodeType == 1){                    //检查是否为元素节点<br>
num++;                              //如果是，计数器加1<br>
console.log(n.nodeName);            //输出元素节点名称<br>
}<br>
var son = n.childNodes;                 //获取所有子节点<br>
for(var i=0 ; i&lt;son.length ; i++){      //遍历每个子元素<br>
num += getElCount(son[i]);    //递归操作<br>
}<br>
return num;                             //返回统计值<br>
}<br>
window.onload=function(){<br>
console.log('文档中元素节点的个数是：'+getElCount(document)+'个')<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[全排列]]></title>
        <id>https://TianhaoXi.github.io/post/quan-pai-lie/</id>
        <link href="https://TianhaoXi.github.io/post/quan-pai-lie/">
        </link>
        <updated>2020-08-22T12:03:05.000Z</updated>
        <content type="html"><![CDATA[<p>var permute = function(nums) {<br>
const list = [];<br>
backtrack(list, [], nums)<br>
return list<br>
};</p>
<p>function backtrack(list,templist,num){<br>
if(templist.length === num.length){<br>
list.push([...templist])<br>
}<br>
for(let i=0;i&lt;num.length;i++){<br>
if(templist.includes(num[i])){<br>
continue;<br>
}<br>
templist.push(num[i]);<br>
backtrack(list,templist,num);<br>
templist.pop()<br>
}<br>
}</p>
<p>var permute = function(nums) {<br>
let n = nums.length;<br>
nums = nums.sort((a,b) =&gt; {return a - b});<br>
let res = [];<br>
let tmpPath = [];<br>
let hash = {};<br>
let backtrack = (tmpPath) =&gt; {<br>
if(tmpPath.length == n){<br>
res.push(tmpPath);<br>
return;<br>
}<br>
for(let i = 0;i &lt; n;i++){<br>
if(hash[i] || (i &gt; 0 &amp;&amp; !hash[i-1] &amp;&amp; nums[i-1] == nums[i])) continue;<br>
hash[i] = true;<br>
tmpPath.push(nums[i]);<br>
backtrack([...tmpPath]);<br>
hash[i] = false;<br>
tmpPath.pop();<br>
}<br>
}<br>
backtrack(tmpPath);<br>
return res;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[merge sort]]></title>
        <id>https://TianhaoXi.github.io/post/merge-sort/</id>
        <link href="https://TianhaoXi.github.io/post/merge-sort/">
        </link>
        <updated>2020-08-22T08:06:15.000Z</updated>
        <content type="html"><![CDATA[<p>// merge Sort<br>
function mergeSort(arr) { // 采用自上而下的递归方法<br>
var length = arr.length;<br>
if (length &lt; 2) {<br>
return arr;<br>
}</p>
<pre><code>var middle = Math.floor(length / 2);
var left = arr.slice(0, middle);
var right = arr.slice(middle);

return merge(mergeSort(left), mergeSort(right));
</code></pre>
<p>}</p>
<p>function merge(left, right) {<br>
var result = [];<br>
console.log('left', left, 'right', right);<br>
while (left.length &amp;&amp; right.length) {<br>
if (left[0] &lt;= right[0]) {<br>
result.push(left.shift());<br>
} else {<br>
result.push(right.shift());<br>
}<br>
}</p>
<pre><code>while (left.length) {
  result.push(left.shift());
}

while (right.length) {
  result.push(right.shift());
}
return result;
</code></pre>
<p>}</p>
<p>var array = [3,5,1,2,3,5,6,7]<br>
var result = mergeSort(array);<br>
console.log(result)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[matrix_clodckspin]]></title>
        <id>https://TianhaoXi.github.io/post/matrix_clodckspin/</id>
        <link href="https://TianhaoXi.github.io/post/matrix_clodckspin/">
        </link>
        <updated>2020-08-22T08:04:52.000Z</updated>
        <content type="html"><![CDATA[<p>function printMatrix(matrix)<br>
{<br>
// write code here</p>
<pre><code>var row = matrix.length;
var col = matrix[0].length;
   

var res = [];
if(row ==0 || col == 0){
    return null;
}

var left = 0; var right = col - 1; var top=0; var bottom = row-1;

while(left&lt;= right &amp;&amp; top &lt;= bottom ){
    
    for(var i =left; i&lt;= right; i++){
        res.push(matrix[top][i]);
    }
    for(var i = top+1; i&lt;= bottom;i++ ){
        res.push(matrix[i][right]);
    }
    if(top != bottom){
        for (var i = right-1;i&gt;= left;i--){
            res.push(matrix[bottom][i]);
        }
    }
    if(left != right){
        for (var i = bottom-1 ; i&gt; top;i--){
            res.push(matrix[i][left]);
        }
    }
  left = left+1;  
  top = top+1;
  right = right -1;
   bottom = bottom -1; 
}
return res;
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quick sort]]></title>
        <id>https://TianhaoXi.github.io/post/quick-sort/</id>
        <link href="https://TianhaoXi.github.io/post/quick-sort/">
        </link>
        <updated>2020-08-22T08:04:33.000Z</updated>
        <content type="html"><![CDATA[<p>// quick sort</p>
<p>function quicksort(array){<br>
if(array.length&lt;2){<br>
return array;<br>
}</p>
<pre><code>var piviotindex = Math.floor(array.length/2)
var pivot = array.splice(piviotindex,1)[0];
var left =[];
var right = [];

for(var i =0;i&lt;array.length;i++){
    if(array[i]&lt;pivot){
        left.push(array[i])
    }
    else{
        right.push(array[i])
    }
}

return quicksort(left).concat([pivot],quicksort(right))
</code></pre>
<p>}</p>
<p>////////////////////<br>
function quickSort(arr, left, right) {<br>
if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof length === 'number' &amp;&amp; typeof right === 'number') {</p>
<pre><code>  if (left &lt; right) {
    var pivot = arr[left]; // 起始位置
    var setPos = left + 1; // 设置的位置
    for (var i = left + 1; i &lt;= right; i++) {
      if (arr[i] &lt; pivot) {
        swap(arr,i,setPos)
        setPos++;
      }
    }
    // 循环完成之后将key与 pos-1的位置交换
    swap(arr,left,setPos-1)

    // console.log('每一次排序', '当前key值===&gt;', key, '排序完成当前数组===&gt;', JSON.stringify(arr));

    quickSort(arr, left, setPos - 2);
    quickSort(arr, setPos, right);
    // console.log('arr=======&gt;', arr);
  }
} else {
  return 'array is not an Array or left or right is not a number!';
}
return arr;
</code></pre>
<p>}</p>
<p>function swap(obj, a, b) { var tmp = obj[a]; obj[a] = obj[b]; obj[b] = tmp; }</p>
<p>var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];<br>
// var arr = [7, 3, 2, 10, 13, 8, 5];<br>
console.log(quickSort(arr, 0, arr.length - 1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Heap sort]]></title>
        <id>https://TianhaoXi.github.io/post/heap-sort/</id>
        <link href="https://TianhaoXi.github.io/post/heap-sort/">
        </link>
        <updated>2020-08-22T08:02:40.000Z</updated>
        <content type="html"><![CDATA[<p>function swap(obj, a, b) { var tmp = obj[a]; obj[a] = obj[b]; obj[b] = tmp; }</p>
<p>function bubbleup(array,index){<br>
const parentindex = Math.floor((index-1)/2)<br>
if(array[parentindex] &amp;&amp; array[parentindex]&lt;array[index]){<br>
swap(array,parentindex,index)<br>
bubbleup(array,parentindex);<br>
}<br>
return;<br>
}</p>
<p>function bubbledown(arr,index,size){<br>
var left = index * 2 + 1;<br>
while (left &lt; size) {<br>
var largest = left + 1 &lt; size &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;<br>
largest = arr[largest] &gt; arr[index] ? largest : index;<br>
if (largest == index) {<br>
break;<br>
}<br>
swap(arr, largest, index);<br>
index = largest;<br>
left = index * 2 + 1;<br>
}<br>
}</p>
<p>function heapSort(arr) {<br>
if (arr == null || arr.length &lt; 2) {<br>
return;<br>
}</p>
<pre><code>for (var i = 0; i &lt; arr.length; i++) {
    bubbleup(arr, i);
}
var size = arr.length;
swap(arr, 0, --size);
while (size &gt; 0) {
    bubbledown(arr, 0, size);
    swap(arr, 0, --size);
}
</code></pre>
<p>}</p>
<p>var arr = [91, 60, 96, 13, 35, 65, 46, 65, 10, 30, 20, 31, 77, 81, 22];<br>
heapSort(arr);<br>
console.log(arr)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划常见题]]></title>
        <id>https://TianhaoXi.github.io/post/dong-tai-gui-hua-chang-jian-ti/</id>
        <link href="https://TianhaoXi.github.io/post/dong-tai-gui-hua-chang-jian-ti/">
        </link>
        <updated>2020-08-22T03:25:36.000Z</updated>
        <content type="html"><![CDATA[<p>代金券组合😎dp<br>
function coinChange(coins,amount){<br>
let dp = new Array(amount+1).fill(Infinity)<br>
dp[0]=0;<br>
for(let coin of coins){<br>
for(let i =1;i&lt;=amount;i++){<br>
if(i-coin&gt;=0){<br>
dp[i]=Math.min(dp[i],dp[i-coin]+1)<br>
}<br>
}<br>
}</p>
<pre><code>return dp[amount] === Infinity ? 'Impossible' : dp[amount];
</code></pre>
<p>}</p>
<p>最小路径和：<br>
function minPath(grid){<br>
let m = grid.length;<br>
let n = grid[0].length;</p>
<pre><code>for(let i =m-1;i&gt;=0;i--){
    for(let j=n-1;j&gt;=0;j--){
        if (i + 1 &lt; m &amp;&amp; j + 1 &lt; n) {
            grid[i][j] += Math.min(grid[i + 1][j], grid[i][j + 1])
        } else if (i + 1 &lt; m) {
            grid[i][j] += grid[i + 1][j]
        } else if (j + 1 &lt; n) {
            grid[i][j] += grid[i][j + 1]
        }
    }
}
return grid[0][0];   
</code></pre>
<p>}</p>
<p>01 背包<br>
var line=readline().split(' ');<br>
var N=parseInt(line[0]);//承重<br>
var c=parseInt(line[1]);//数量<br>
var w=[0],p=[0];//重 价值<br>
while(lines=readline()){<br>
let nums=lines.split(' ').map(Number);<br>
p.push(nums[0])//;<br>
w.push(nums[1]);<br>
}<br>
function DyadicArray(N, c, w, p) {<br>
//初始化表格<br>
var dp = new Array(N + 1); //表格有n+1行<br>
for (let n = 0; n &lt; N + 1; n++) {<br>
dp[n] = new Array(c + 1).fill(0); //每行有c+1列<br>
}</p>
<p>for (let i = 1; i &lt;= N; i++) {<br>
for (let j = 0; j &lt;= c; j++) {<br>
if (j - w[i] &gt;= 0) {<br>
dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w[i]] + p[i]);<br>
} else {<br>
dp[i][j] = dp[i - 1][j];<br>
}<br>
}<br>
}<br>
return(dp[N][c])<br>
}<br>
console.log(DyadicArray(N, c, w, p))</p>
<p>最长公共子序列</p>
<p>var longestCommonSubsequence = function(text1, text2) {<br>
let n = text1.length;<br>
let m = text2.length;<br>
let dp = Array.from(new Array(n+1),() =&gt; new Array(m+1).fill(0));</p>
<pre><code>for(let i =1;i&lt;=n;i++){
    for(let j=1;j&lt;=m;j++){
        if(text1[i-1]===text2[j-1]){
            dp[i][j] = 1+dp[i-1][j-1];
        }
        else{
            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])
        }
    }
}
return dp[n][m]
</code></pre>
<p>};</p>
<p>01 背包：<br>
function kanpSack(capacity, weights, values, n) {<br>
var a,b,dp = []</p>
<p>//首先，初始化用于寻找解决方案的矩阵KS[n+1][capacity+1]<br>
for (var i = 0; i &lt;= n; i++) {<br>
dp[i] = [];<br>
}<br>
for (var i = 0; i &lt;= n; i++) {<br>
for (var j = 0; j &lt;= capacity; j++) {<br>
if (i === 0 || j === 0) {<br>
//让第一行和第一列为0，因为第一行和第一列表示容量为0或没有物品可装<br>
dp[i][j] = 0;<br>
} else if (weights[i - 1] &gt; j) {<br>
dp[i][j] = dp[i - 1][j]; //当前物品重量大于当前容量<br>
} else {<br>
//当前物品重量小于当前容量，有两个选择，装或者不装，取价值最大的<br>
a = dp[i - 1][j - weights[i - 1]] + values[i - 1]; //装入这个物品后的总价值<br>
b = dp[i - 1][j]; //不装<br>
dp[i][j] = Math.max(a,b)<br>
}<br>
}</p>
<pre><code>}
return dp[n][capacity];
</code></pre>
<p>}</p>
<p>不同的二叉搜索树<br>
var numTrees = function(n) {<br>
let dp = new Array(n+1).fill(0);<br>
dp[0] = 1<br>
dp[1] = 1<br>
for (let i = 2; i &lt;= n; ++i) {<br>
for (let j = 1; j &lt;= i; ++j) {<br>
dp[i]  += dp[j-1] * dp[i-j];<br>
}<br>
}<br>
return dp[n]<br>
};</p>
<p>无重复字符的最长子串</p>
<p>var lengthOfLongestSubstring = function(s) {</p>
<pre><code>let max = 0;
let arr = [];
for(let i =0;i&lt;s.length;i++){
    let index = arr.indexOf(s[i]);
    if(index !== -1){
        arr.splice(0,index+1)
    }
    arr.push(s[i]);
    max = Math.max(arr.length,max)
}
return max
</code></pre>
<p>};</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题目总结]]></title>
        <id>https://TianhaoXi.github.io/post/mian-shi-ti-mu-zong-jie/</id>
        <link href="https://TianhaoXi.github.io/post/mian-shi-ti-mu-zong-jie/">
        </link>
        <updated>2020-08-17T01:31:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="说一下redux的几个概念"><strong>说一下redux的几个概念：</strong></h1>
<p>redux把应用的所有状态集中在一起，这样可在应用越来越大、越来越复杂时方便管理<br>
redux主要包括一下几个方法：<br>
createStore()      // 创建store<br>
getState()           // 获取state<br>
dispatch()          // 分发action<br>
subscribe()       // 订阅store<br>
combineReducers //合并多个reducer<br>
需要知道 redux 不能直接更改 state ，而是通过dispatch（分发）action（描述此次改动的细节）来创建一个新的state ，这样有利于跟踪每一次改动。<br>
reducer 就像一个处理器，而action像一个指令<br>
reducer接受 action ，根据action的type来确定需要执行的更新操作。<br>
在发生更新时便会触发所有已经subscribe的函数，通常这些函数用以更新UI 层。<br>
Provider 把根组件包裹起来，将store注入整个应用中。这样就不用通过props把store一级一级地往下传。<br>
connect 用以构造 容器组件 。connect可映射state和dispatch到容器组件的props中， 然后便能在UI组件中显示state数据，或者dispatch action<br>
connect后就不需要再写subscribe来操作更新了</p>
<h1 id="函数的this指向">函数的this指向</h1>
<p>全局函数的this都是指向的window。<br>
当一个函数并非一个对象的属性时，那么它就是被当做函数来调用的。在此种模式下，this被绑定为全局对象，在浏览器环境下就是window对象<br>
当函数被保存为一个对象的属性时，它就可称为这个对象的方法。当一个方法被调用时，this被绑定到这个对象上。如果调用表达式包含一个提取属性的动作（. 或 []），那么它被称为方法调用<br>
构造函数调用模式<br>
如果在一个函数前面加上new关键字来调用，那么就会创建一个连接到该函数的prototype成员的新对象，同时，this会被绑定到这个新对象上。这种情况下，这个函数就可以成为此对象的构造函数。</p>
<h1 id="进程和线程">进程和线程</h1>
<p>一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。<br>
一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。<br>
互斥锁&quot;（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。<br>
内存区域，只能供给固定数目的线程使用。<br>
进程具有的特征：<br>
动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；<br>
并发性：任何进程都可以同其他进行一起并发执行；<br>
独立性：进程是系统进行资源分配和调度的一个独立单位；<br>
结构性：进程由程序，数据和进程控制块三部分组成<br>
线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；<br>
进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；</p>
<p>内核会为系统中每一个进程维护一份相互独立的页映射表。。页映射表的基本原理是将程序运行过程中需要访问的一段虚拟内存空间通过页映射表映射到一段物理内存空间上，这样CPU访问对应虚拟内存地址的时候就可以通过这种查找页映射表的机制访问物理内存上的某个对应的地址。“页（page）”是虚拟内存空间向物理内存空间映射的基本单元。</p>
<h1 id="generator">generator</h1>
<p>generator由function*定义<br>
调用generator对象有两个方法，一是不断地调用generator对象的next()方法：<br>
next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。<br>
for ... of循环迭代generator对象<br>
异步回调代码变成“同步”代码</p>
<h1 id="http请求的四个部分">HTTP请求的四个部分：</h1>
<p>1、HTTP请求的方法或者动作，GET或者POST等<br>
Request Method: POST<br>
请求地址URL（你连URL地址都没有你请求什么）<br>
Request URL:https://contract-web.uat.yixincapital.com/contract2.0-web/<br>
请求头，包含客户端环境信息，身份验证信息<br>
客户端浏览器请求Header(HTTP request header)<br>
Accept 可接受的内容类型<br>
Accept-Language 语言<br>
Accept-Encoding 可接受的压缩类型 gzip,deflate<br>
Accept-Charset 可接受的内容编码 UTF-8,*<br>
Content-Type: application/x-www-form-urlencoded; charset=UTF-8(内容类型，这种表示key-value形式，下方有from data)<br>
Content-Type: application/json;charset=utf-8（内容类型，这种表示json形式，请求体为json形式，没有from data<br>
Cookie:JSESSIONID=F06E92B6119E19B000BC43F40984A575（cookie）<br>
Host  请求的域名<br>
Origin:https://contract-web.uat.yixincapital.com（最初请求从哪个网站跳过来的）<br>
Referer:https://contract-web.uat.yixincapital.com/contract2.0-web/contract2.0-vue//contractManage/index.html（从哪个网站跳过来的）<br>
User-Agent 浏览器端浏览器型号和版本<br>
X-Requested-With:XMLHttpRequest（ 如果 requestedWith 为 null，则为同步请求。 如果 requestedWith 为 XMLHttpRequest 则为 Ajax 请求）</p>
<p>请求体，即请求正文，请求正文可以包含客户提交的查询字符，表单信息等等</p>
<p>二、一个HTTP响应由三部分组成：<br>
1、一个数字与文字组成的状态码，用来显示请求成功失败信息<br>
Status Code:  200 OK<br>
2、响应头，响应头与请求头包含许多有用信息，例如：服务器类型、日期时间、内容类型和长度等。<br>
服务器端的响应Header(response header)<br>
Connection:keep-alive（ 针对该连接所预期的选项）<br>
Content-Disposition:inline;filename=f.txt（ 对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。）<br>
Content-Type:application/json;charset=UTF-8（ 当前内容的MIME类型）<br>
Date:Wed, 07 Nov 2018 09:33:39 GMT*（ 此条消息被发送时的日期和时间(以RFC 7231中定义的&quot;HTTP日期&quot;格式来表示)）<br>
Server:Tengine（ 服务器的名称）<br>
Transfer-Encoding: chunked（ 用表示实体传输给用户的编码形式。包括：chunked、compress、 deflate、gzip、identity。）<br>
3、响应体，响应正文</p>
<p>三、HTTP常见状态码：<br>
1xx	Informational（信息性状态码）	接受的请求正在处理<br>
2xx	Success（成功状态码）	请求正常处理完毕<br>
3xx	Redirection（重定向）	需要进行附加操作以完成请求<br>
4xx	Client error（客户端错误）	客户端请求出错，服务器无法处理请求<br>
5xx	Server Error（服务器错误）	服务器处理请求出错</p>
<p>200 OK：表示从客户端发送给服务器的请求被正常处理并返回；<br>
202：表示服务器已经接受了请求，但是还没有处理，而且这个请求最终会不会处理还不确定<br>
204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）；<br>
206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。</p>
<p>301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；<br>
302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；<br>
301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）<br>
303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；<br>
302与303的区别：后者明确表示客户端应当采用GET方式获取资源<br>
304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；<br>
307 Temporary Redirect：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；</p>
<p>400 Bad Request：表示请求报文中存在语法错误；<br>
401 Unauthorized：未经许可，需要通过HTTP认证；<br>
403 Forbidden：服务器拒绝该次访问（访问权限出现问题）<br>
404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</p>
<p>500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；<br>
503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</p>
<h1 id="content-type">content-type</h1>
<p>text/plain 　　　　　　　　文本类型<br>
text/css  　　　　　　　　 css类型<br>
text/html 　　 　　　　　　html类型<br>
application/x-javascript 　　js类型<br>
application/json　　　　　 json类型<br>
image/png jpg gif　　　　　 image/*</p>
<h1 id="断点续传">断点续传</h1>
<p>HTTP1.1 协议（RFC2616）开始支持获取文件的部分内容，这为并行下载以及断点续传提供了技术支持。它通过在 Header 里两个参数实现的，客户端发请求时对应的是 Range ，服务器端响应时对应的是 Content-Range。<br>
Range:<br>
用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：<br>
HTTP/1.1 206 Partial Content（使用断点续传方式）</p>
<h1 id="http如何控制请求的数量">http如何控制请求的数量</h1>
<p>TTP 连接产生的开销<br>
域名解析–TCP 连接–发送请求–等待–下载资源–解析时间<br>
（减少开销：DNS缓存、Keep-Alive）<br>
合并脚本和样式表，使用外部的 js 和 css 文件引用的方式，因为这要比直接写在页面中性能要更好一点；独立的一个 js 比用多个 js 文件组成的页面载入要快 38%<br>
图片使用 Base64 编码减少页面请求数。采用 Base64 的编码方式将图片直接嵌入到网页中，而不是从外部载入。（高版本浏览器解析）<br>
首屏渲染---文件样式布局主要由js文件决定，合并之后的js文件变大，会导致首屏渲染很慢<br>
缓存失效---合并之后，修改了一个js文件，导致整个合并的代码重新加载，缓存失效</p>
<p>#从输入url到页面展现发生了什么？其中在页面渲染以及网络请求响应的性能优化方面，我们分别可以做哪些优化工作？<br>
请求页面<br>
1、dns解析<br>
- 先在本地host查找<br>
- 到浏览器dns缓存查找<br>
- 到根域名服务器查找<br>
- 找主域名服务器查找<br>
- 返回ip地址<br>
2、浏览器缓存<br>
- 强缓存maxAge未过时直接读取本地磁盘缓存，无需建立连接<br>
- 协商缓存if-modify-since --&gt; etag （优先级高）<br>
3、没有缓存，建立tcp连接<br>
- 三次握手 syn -&gt; syn+ack -&gt; fin<br>
- 建立SSL通信，客户端携带随机数，支持的加密算法列表请求443端口 -&gt; 服务端返回数字证书+公钥+随机数b -&gt; 客户端验证证书有效性生成随机数c，用某种加密算法根据abc生成对称密钥，并返回给服务端 -&gt; 服务端私钥解密，得到对称密钥，然后双方使用对称密钥通信<br>
// - 复杂请求，先发起option请求检验服务可用性<br>
- 接收数据包（请求头，请求行，请求体）根据content-type进行解码，根据不同资源类型进行不同的加载策略<br>
- 四次挥手 syn -&gt; syn + ack -&gt; fin -&gt; ack + fin<br>
4、浏览器渲染<br>
- 浏览器主进程通知渲染进程可以开始渲染了<br>
- 渲染进程接收到垂直同步信号，通知主线程<br>
- 主线程先进行渲染的前置操作，清空当前的所有微任务，之后触发requestAnimationFrame，进入渲染阶段<br>
- 构建dom树 + css renderer -&gt; 得到layout树<br>
-根据图层生成规则，并计算节点位置，生成layer树<br>
- 通知合成线程，layer树准备完毕<br>
- 合成线程进行分块和光栅化的操作<br>
- 通知gpu可以开始进行绘制了<br>
- gpu调用显示器提供的DirectX api，ldp，aldp不同策略进行得到色彩页面显示<br>
- （中间会穿插css的加载，js的执行，defer，async等不同策略）</p>
<p>输入url按下回车之后，浏览器会去浏览器缓存中寻找该url的ip；没有的话去系统缓存中找，还是没有的话去路由器缓存中寻找；再没有就去系统host文件中找，还是没有最后只能去请求dns服务器，然后dns给一个ip给浏览器；浏览器根据这个ip地址，将请求信息，请求说明和请求参数等封成一个tcp包，由传输层，到网络层，到数据链路层到物理层，传送给服务器，服务器解析这个tcp包将对应的页面文件返回。浏览器根据html文件生成dom树，根据css文件生成cssom树，然后合并这两棵树生成渲染树，然后渲染页面并且展示。要注意的是，当浏览器解析html文件时候如果遇到了内联或者外联的js代码，会暂停dom树的生成，等js代码执行完成之后，才能继续生成树并渲染。<br>
其中在页面渲染以及网络请求响应的性能优化方面，我们可以做的优化工作有：1.js代码写在页面渲染完成之后避免阻塞渲染    2.cdn并发，资源压缩，减少请求次数    3.预加载或者懒加载</p>
<h1 id="拥塞控制">拥塞控制</h1>
<p>TCP的四种拥塞控制算法<br>
1.慢开始<br>
2.拥塞控制<br>
3.快重传<br>
4.快恢复<br>
拥塞控制：<br>
https://www.cnblogs.com/kubidemanong/p/9973757.html<br>
流量控制：<br>
https://www.cnblogs.com/kubidemanong/p/9987810.html<br>
增长阶段称之为慢启动，线性增长阶段称之为拥塞避免</p>
<p>拥塞控制与网络的拥堵情况相关联，而流量控制与接收方的缓存状态相关联。</p>
<h1 id="cookies-localstorage-sessionstorage">cookies localStorage sessionStorage</h1>
<p>Cookie 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效<br>
每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题<br>
服务器像客户端发送cookie<br>
浏览器将cookie保存<br>
之后每次http请求浏览器都会将cookie发送给服务器端 Set-Cookie中设置</p>
<p>#tcp的连接<br>
https://blog.csdn.net/weixin_44907813/article/details/90444151</p>
<p><img src="https://TianhaoXi.github.io/post-images/1597643981310.png" alt="" loading="lazy"><br>
<img src="https://TianhaoXi.github.io/post-images/1597644169819.png" alt="" loading="lazy"></p>
<h1 id="跨域和解决方法">跨域和解决方法</h1>
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>
<p>jsonp:<br>
同源策略请求: ajax fetch<br>
script img link  标签不存在跨域<br>
jsonp只能处理get请求</p>
<p>clint:<br>
$.ajax({<br>
url : 'http://localhost:3002/api/data1',<br>
dataType : 'jsonp',<br>
type : 'get',<br>
success : function(res){<br>
console.log(res);<br>
},<br>
error: function() {<br>
console.log(&quot;fail&quot;)<br>
}<br>
});</p>
<p>server:<br>
let routerJsonp = new Router();<br>
routerJsonp.get('/data1', async (ctx) =&gt; {<br>
let cb = ctx.request.query.callback;<br>
ctx.type = 'text/javascript'<br>
let returnData = {<br>
success: true,<br>
data: {<br>
text: 'this is a jsonp api',<br>
time: new Date().getTime(),<br>
}<br>
}<br>
// jsonp的script字符串<br>
let jsonpStr = <code>;${callbackName}(${JSON.stringify(returnData)})</code><br>
ctx.body = jsonpStr<br>
})</p>
<p>router.get('/data1', async (ctx) =&gt; {<br>
let cb = ctx.request.query.callback;<br>
ctx.type = 'text';<br>
ctx.body = cb + '(' + '&quot;数据&quot;' + ')';<br>
})</p>
<p>CORS：<br>
axios.get('http://127.0.0.01:3001/user/list').then(res=&gt;{<br>
console.log(res)<br>
})</p>
<p>const cors = require('koa2-cors');<br>
app.use(async (ctx, next) =&gt; {<br>
// 允许来自所有域名请求<br>
ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);<br>
// 这样就能只允许 http://localhost:8080 这个域名的请求了<br>
// ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8080&quot;);</p>
<pre><code>// 设置所允许的HTTP请求方法
ctx.set(&quot;Access-Control-Allow-Methods&quot;, &quot;OPTIONS, GET, PUT, POST, DELETE&quot;);

// 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段.
ctx.set(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with, accept, origin, content-type&quot;);

// 服务器收到请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。

// Content-Type表示具体请求中的媒体类型信息
ctx.set(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);

// 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。
// 当设置成允许请求携带cookie时，需要保证&quot;Access-Control-Allow-Origin&quot;是服务器有的域名，而不能是&quot;*&quot;;
ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);

// 该字段可选，用来指定本次预检请求的有效期，单位为秒。
// 当请求方法是PUT或DELETE等特殊方法或者Content-Type字段的类型是application/json时，服务器会提前发送一次请求进行验证
// 下面的的设置只本次验证的有效时间，即在该时间段内服务端可以不用进行验证
ctx.set(&quot;Access-Control-Max-Age&quot;, 300);

/*
CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：
    Cache-Control、
    Content-Language、
    Content-Type、
    Expires、
    Last-Modified、
    Pragma。
*/
// 需要获取其他字段时，使用Access-Control-Expose-Headers，
// getResponseHeader('myData')可以返回我们所需的值
ctx.set(&quot;Access-Control-Expose-Headers&quot;, &quot;myData&quot;);

await next();
</code></pre>
<p>})</p>
<p>3 http proxy:</p>
<p>const proxy = require('http-proxy-middleware');<br>
module.exports = function (app) {<br>
app.use(proxy('/api', { target: 'http://localhost:3002/' }));<br>
};</p>
<p>CSRF：<br>
<img src="https://TianhaoXi.github.io/post-images/1597663497671.jpg" alt="" loading="lazy"></p>
<h1 id="回流和重绘">回流和重绘</h1>
<p>https://www.jianshu.com/p/e081f9aa03fb<br>
当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。<br>
当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。<br>
https://blog.csdn.net/binlety/article/details/81390346<br>
https://blog.csdn.net/weixin_30289831/article/details/97202752?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param<br>
https://blog.csdn.net/qq_36360463/article/details/105129688?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</p>
<h1 id="一次性加载一万个标签">一次性加载一万个标签</h1>
<p>document.createDocumentFrament</p>
<script>
	var container = document.getElementById('container')
	var fragment = document.createDocumentFragment()
	for(let i = 0; i < 10000; i++){
		let li = document.createElement('li')
		li.innerHTML = 'hello world'
	    fragment.appendChild(li)
	}
	container.appendChild(fragment);
</script>
<p>前端工程化:<br>
模块化<br>
简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。只有这样，才有多人协作的可能。<br>
组件化</p>
<h1 id="节流和防抖">节流和防抖</h1>
<p>对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。<br>
https://segmentfault.com/a/1190000018428170</p>
<p>function debounce(func,wait){<br>
let timer;</p>
<pre><code>return function(){
    clearTimeout(timer);
    timer = setTimeout(func,wait)
}
</code></pre>
<p>}</p>
<p>function real(){<br>
console.log(&quot;123&quot;);<br>
}</p>
<p>function throttle(func,wait,mustrun){<br>
let timeout,starttime = new Date();</p>
<pre><code>return ()=&gt;{
    let currenttime = new Date();
    clearTimeout(timeout)
    if(currenttime-starttime&gt;mustrun){
        func.apply(this,arguments)
        starttime = currenttime
    }
    else{
        timeout = setTimeout(func,wait)
    }
}
</code></pre>
<p>}</p>
<p>window.addEventListener(&quot;scroll&quot;,throttle(real,1000,1000))</p>
<p>#清除浮动<br>
方法一：使用带clear属性的空元素<br>
在浮动元素后使用一个空元素如<div class="clear"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用<br class="clear" />或<hr class="clear" />来进行清理。</p>
<p>.clearfix:after{/<em>伪元素是行内元素 正常浏览器清除浮动方法</em>/<br>
content: &quot;&quot;;<br>
display: block;<br>
height: 0;<br>
clear:both;<br>
visibility: hidden;<br>
}</p>
<p>BFC:<br>
三、触发 BFC<br>
只要元素满足下面任一条件即可触发 BFC 特性：<br>
body 根元素<br>
浮动元素：float 除 none 以外的值<br>
绝对定位元素：position (absolute、fixed)<br>
display 为 inline-block、table-cells、flex<br>
overflow 除了 visible 以外的值 (hidden、auto、scroll)</p>
<h1 id="css居中">css居中</h1>
<p>行内水平 text-align:center</p>
<p>block居中:<br>
display:flex;<br>
align-items: center;<br>
justify-content:center;</p>
<p>position:absolute;<br>
left:50%;<br>
top:50%;<br>
transform: translate(-50%,-50%);</p>
<p>#左边固定宽度，右边自适应<br>
1.<br>
.left{<br>
float: left;<br>
width: 200px;<br>
background: red;<br>
}<br>
.right{<br>
margin-left: 200px;<br>
background: blue;<br>
}</p>
<ol start="2">
<li>
<p>.right{<br>
overflow: hidden;<br>
background: blue;<br>
}</p>
</li>
<li>
<p>flex:<br>
.wrapper{<br>
display: flex;<br>
}<br>
.left,.right{<br>
height: 100px;<br>
}<br>
.left{<br>
width: 200px;<br>
background: red;<br>
}<br>
.right{<br>
flex: 1;<br>
background: blue;<br>
}</p>
</li>
</ol>
<h1 id="白屏优化">白屏优化</h1>
<p>https://blog.csdn.net/PHPxiaoxuesheng/article/details/100935993</p>
<p>#强缓存与协商缓存<br>
https://www.jianshu.com/p/9c95db596df5<br>
强缓存<br>
到底什么是强缓存？强在哪？其实强是强制的意思。当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制，具体表现为：<br>
respone header 的cache-control，常见的设置是max-age public private no-cache no-store等<br>
如果cahe-control:max-age=315360000,public再加个immutable的话，就算用户刷新页面，浏览器也不会发起请求去服务，浏览器会直接从本地磁盘或者内存中读取缓存并返回200状态</p>
<h1 id="浏览器的线程">浏览器的线程</h1>
<p>https://segmentfault.com/a/1190000013083967</p>
<h1 id="deepclone">deepClone</h1>
<p>function deepClone(target){<br>
let result;<br>
if(typeof result === 'object'){<br>
if(target instanceof Array){<br>
result = [];<br>
for(let i =0;i&lt;tartget.length;i++){<br>
result.push(deepClone(target[i]))<br>
}<br>
}<br>
else if(target ===null){<br>
result = null;<br>
}<br>
else if( target.<strong>proto</strong>.constructor ===RegExp){<br>
result = target;<br>
}<br>
else{<br>
result = {};<br>
for(let i in target){<br>
result[i] = deepClone(target[i])<br>
}<br>
}<br>
}<br>
else{<br>
result = target;<br>
}</p>
<pre><code>return result;
</code></pre>
<p>}</p>
<h1 id="垃圾回收机制">垃圾回收机制</h1>
<p>https://segmentfault.com/a/1190000018605776?utm_source=tag-newest</p>
<h1 id="cors-简单-复杂请求">cors 简单 复杂请求</h1>
<p>https://www.cnblogs.com/qunxiadexiaoxiangjiao/p/9446956.html</p>
<p>#原生jsonP</p>
<script>
let response = ""
function jsonp_callback(data){
    console.log(data)
    response = data;
}
</script>
<script src="http://localhost:3002/api/comment?callback=jsonp_callback_function"">
</script>
<p>#bind curry<br>
Function.prototype.bind = function (context) {<br>
var _this = this<br>
var args = Array.prototype.slice.call(arguments, 1)</p>
<pre><code>return function() {
    return _this.apply(context, args)
}
</code></pre>
<p>}</p>
<p>mvc mvvm<br>
M、V、C<br>
Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。<br>
通常模型对象负责在数据库中存取数据。<br>
View（视图）：是应用程序中处理数据显示的部分。<br>
通常视图是依据模型数据创建的。<br>
Controller（控制器）：是应用程序中处理用户交互的部分。<br>
通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。<br>
mvvm:<br>
View的变动，自动反映在 ViewModel，反之亦然。</p>
<h1 id="事件委托">事件委托</h1>
<p>window.onload = function(){<br>
　　var oUl = document.getElementById(&quot;ul1&quot;);<br>
　　oUl.onclick = function(ev){<br>
　　　　var ev = ev || window.event;<br>
　　　　var target = ev.target || ev.srcElement;<br>
　　　　if(target.nodeName.toLowerCase() == 'li'){<br>
　 　　　　　　 alert(123);<br>
　　　　　　　  alert(target.innerHTML);<br>
　　　　}<br>
　　}<br>
}</p>
<h1 id="箭头函数">箭头函数：</h1>
<p>ES6 增加了箭头函数，基本语法为<br>
let func = value =&gt; value;</p>
<p>相当于</p>
<p>let func = function (value) {</p>
<p>return value;</p>
<p>};</p>
<p>箭头函数与普通函数的区别在于：</p>
<p>1、箭头函数没有this，所以需要通过查找作用域链来确定this的值，这就意味着如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this，</p>
<p>2、箭头函数没有自己的arguments对象，但是可以访问外围函数的arguments对象</p>
<p>3、不能通过new关键字调用，同样也没有new.target值和原型</p>
<p>#简单讲一讲ES6的一些新特性</p>
<p>ES6在变量的声明和定义方面增加了let、const声明变量，有局部变量的概念，赋值中有比较吸引人的结构赋值，同时ES6对字符串、 数组、正则、对象、函数等拓展了一些方法，如字符串方面的模板字符串、函数方面的默认参数、对象方面属性的简洁表达方式，ES6也 引入了新的数据类型symbol，新的数据结构set和map,symbol可以通过typeof检测出来，为解决异步回调问题，引入了promise和 generator，还有最为吸引人了实现Class和模块，通过Class可以更好的面向对象编程，使用模块加载方便模块化编程，当然考虑到 浏览器兼容性，我们在实际开发中需要使用babel进行编译<br>
重要的特性：</p>
<p>块级作用域：ES5只有全局作用域和函数作用域，块级作用域的好处是不再需要立即执行的函数表达式，循环体中的闭包不再有问题</p>
<p>rest参数：用于获取函数的多余参数，这样就不需要使用arguments对象了，</p>
<p>promise:一种异步编程的解决方案，比传统的解决方案回调函数和事件更合理强大</p>
<p>模块化：其模块功能主要有两个命令构成，export和import，export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能</p>
<p>文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。</p>
<p>webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源</p>
<p>redux<br>
在组件化的应用中，会有着大量的组件层级关系，深嵌套的组件与浅层父组件进行数据交互，变得十分繁琐困难。而redux，站在一个服务级别的角度，可以毫无阻碍地将应用的状态传递到每一个层级的组件中。redux就相当于整个应用的管家。<br>
提供 getState() 方法获取 state；<br>
提供 dispatch(action) 方法更新 state；<br>
通过 subscribe(listener) 注册监听器;<br>
React 是一个用于构建用户界面的 JAVASCRIPT 库。React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）<br>
React特点有：</p>
<p>1.声明式设计 −React采用声明范式，可以轻松描述应用。</p>
<p>2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。</p>
<p>3.灵活 −React可以与已知的库或框架很好地配合。</p>
<p>4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。</p>
<p>5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。</p>
<p>6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。<br>
在React中，数据是单向流动的，是从上向下的方向，即从父组件到子组件的方向。<br>
state和props是其中重要的概念，如果顶层组件初始化props，那么React会向下遍历整颗组件树，重新渲染相关的子组件。其中state表示的是每个组件中内部的的状态，这些状态只在组件内部改变。<br>
把组件看成是一个函数，那么他接受props作为参数，内部由state作为函数的内部参数，返回一个虚拟dom的实现。<br>
diff算法，diff算法有三种优化形式：<br>
tree diff：将新旧两颗DOM树按照层级遍历，只对同级的DOM节点进行比较，即同一父节点下的所有子节点，当发现节点已经不存在，则该节点及其子节点会被完全删除，不会进一步比较</p>
<p>component diff：不同组件之间的对比，如果组件类型相同，暂不更新，否则删除旧的组件，再创建一个新的组件，插入到删除组件的位置</p>
<p>element diff:在类型相同的组件内，再继续对比组件内部的元素，</p>
<p>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。 经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。 在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。 在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p>
<p>单例模式：在它的核心结构中值包含一个被称为单例的特殊类。一个类只有一个实例，即一个类只有一个对象实例。<br>
工厂模式：在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p>发布订阅模式：在软件架构中，发布订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。</p>
<h1 id="前端性能优化">前端性能优化</h1>
<p>前端性能优化有七大手段：减少请求数量，减少资源大小，优化网络连接，优化资源加载，减少重绘回流，使用性能更好的API和构建优化<br>
减少请求数量：通过减少重定向，使用缓存，不适用CSS@import，避免使用空的src和href等手段</p>
<p>减少资源大小：通过压缩HTML，CSS，JS，图片，此外在安卓下可以使用webp格式的图片，它具有更优的图像数据压缩算法，能带来更小的图片体积，还可以开启gzip,gzip编码是以后总用来改进web应用程序性能的技术，</p>
<p>优化网络连接：使用CDN，使用DNS预解析，并行连接，</p>
<p>优化资源加载，通过优化资源加载位置和时机，使用资源预加载preload和资源预读取prefetch</p>
<p>减少重绘回流，1：避免使用层级较深的CSS选择器，以提高CSS渲染效率2、避免使用CSS表达式，3、给元素适当的定义高度或最小高度，否则元素的动态内容载入时，会出现页面晃动，造成回流，4、不要使用table布局，5、能用CSS实现的效果，尽量使用CSS而不用JS实现</p>
<p>使用性能更好的api,</p>
<p>随机创造hex<br>
let hex = ()=&gt;{<br>
return res = &quot;#&quot;+Math.floor(Math.random()*0xffffff).toString(16)<br>
}</p>
<p>hex2rgb<br>
function hexToRgb(hex) {<br>
return &quot;rgb(&quot; + parseInt(&quot;0x&quot; + hex.slice(1, 3)) + &quot;,&quot; + parseInt(&quot;0x&quot; + hex.slice(3, 5)) + &quot;,&quot; + parseInt(&quot;0x&quot; + hex.slice(5, 7))<br>
}</p>
<p>使用new调用函数时，会执行[[construct]]方法：<br>
(1) 在内存中创建一个继承自 fn.prototype 的新对象<br>
(2) 把函数体的this指向新对象，并执行函数体。<br>
(3) 默认返回新对象。如果构造函数指定的返回值为复杂类型，会覆盖掉默认返回值。</p>
]]></content>
    </entry>
</feed>