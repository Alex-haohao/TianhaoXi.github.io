<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CSE331 | Alex个人博客</title>
<link rel="shortcut icon" href="https://TianhaoXi.github.io/favicon.ico?v=1600248458344">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://TianhaoXi.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="CSE331 | Alex个人博客 - Atom Feed" href="https://TianhaoXi.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="import numpy as np
import copy
#ci = pi+ki(mod 26)
def task1(plaintext,key):
res = &quot;&quot;
upper = [chr(i) for i in..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://TianhaoXi.github.io">
  <img class="avatar" src="https://TianhaoXi.github.io/images/avatar.png?v=1600248458344" alt="">
  </a>
  <h1 class="site-title">
    Alex个人博客
  </h1>
  <p class="site-description">
    学习，分享，进步
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/TianhaoXi" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              CSE331
            </h2>
            <div class="post-info">
              <span>
                2020-09-16
              </span>
              <span>
                9 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>import numpy as np<br>
import copy</p>
<p>#ci = pi+ki(mod 26)<br>
def task1(plaintext,key):<br>
res = &quot;&quot;<br>
upper = [chr(i) for i in range(65,91)]<br>
lower = [chr(i) for i in range(97,123)]<br>
newCipher = &quot;&quot;<br>
for i in range(len(plaintext)):<br>
newCipher += key[i % len(key)]<br>
counter =0<br>
for i in range(len(plaintext)):<br>
onekey = ord(newCipher[i-counter])<br>
oneplain = ord(plaintext[i])<br>
if chr(oneplain) in lower:<br>
temp = chr((oneplain-32 + onekey) % 26 + 65)<br>
temp = temp.lower()<br>
res += temp<br>
elif chr(oneplain) in upper:<br>
res += (chr((oneplain + onekey) % 26 + 65))<br>
else:<br>
res += chr(oneplain)<br>
counter = counter + 1<br>
print(res)</p>
<p>#pi = ci-ki(mod 26)<br>
def task2(ciphertext,key):<br>
upper = [chr(i) for i in range(65, 91)]<br>
lower = [chr(i) for i in range(97, 123)]<br>
res = &quot;&quot;<br>
counter = 0<br>
newKey = &quot;&quot;<br>
for i in range(len(ciphertext)):<br>
newKey += key[i % len(key)]<br>
##########<br>
counter = 0<br>
for i in range(len(ciphertext)):<br>
onekey = ord(newKey[i - counter])<br>
onecipher = ord(ciphertext[i])<br>
if chr(onecipher) in lower:<br>
temp = chr((onecipher - 32 - onekey) % 26 + 65)<br>
temp = temp.lower()<br>
res += temp<br>
elif chr(onecipher) in upper:<br>
res += (chr((onecipher - onekey) % 26 + 65))<br>
else:<br>
res += chr(onecipher)<br>
counter = counter + 1<br>
print(res)<br>
###########</p>
<p>'''<br>
Once the length of the key is known, the ciphertext can be rewritten into that many columns,<br>
with each column corresponding to a single letter of the key.<br>
Each column consists of plaintext that has been encrypted by a single Caesar cipher.<br>
The Caesar key (shift) is just the letter of the Vigenère key that was used for that column.<br>
Using methods similar to those used to break the Caesar cipher, the letters in the ciphertext can be discovered.<br>
'''<br>
def task3(ciphertext,length):<br>
frequency = [0.082, 0.015, 0.028, 0.043, 0.127, 0.022, 0.02, 0.061, 0.07, 0.002, 0.008, 0.04, 0.024, 0.06, 0.075,<br>
0.019, 0.001, 0.06, 0.063, 0.091, 0.028, 0.01, 0.023, 0.001, 0.02, 0.001]<br>
upper = [chr(i) for i in range(65, 91)]<br>
lower = [chr(i) for i in range(97, 123)]</p>
<pre><code>cipherCounter = 0
for i in range(len(ciphertext)):
    if(ciphertext[i] in upper or ciphertext[i] in lower):
        cipherCounter = cipherCounter+1
key = []
for start in range(length):
    key.append(0)
charShowTime = {}
splitedText = splitTonRow(ciphertext,length)
</code></pre>
<p>#######################################################################</p>
<pre><code>for i in range(length):
    onecipher = splitedText[i]
    cipherCounter = 0
    for n in range(len(onecipher)):
        if (onecipher[n] in upper or onecipher[n] in lower):
            cipherCounter = cipherCounter + 1


    move = 0
    resmove =0
    target = 0.067
    min = 1
    while(1):
        M = 0
        position = 65+move
        charShowTime = {}
        for j in range(26):
            charShowTime[chr(j+65)] = 0

        for j in range (cipherCounter):
            if (onecipher[j] in upper):
                charShowTime[onecipher[j]] = charShowTime[onecipher[j]] + 1
            elif(onecipher[j] in lower):
                temp = onecipher[j].upper()
                charShowTime[temp] = charShowTime[temp] + 1

        for j in range(26):
            currentFrequency = frequency[j]
            if(position &gt;=91):
                position = 65
            f = charShowTime[chr(position)] / cipherCounter
            M += f * currentFrequency
            position = position+1

        # print(M)
        # print(charShowTime)
        if abs(target- M) &lt; min:
            min = abs(target- M)
            resmove = move
        if(move&gt;=26):
            key[i] = resmove+65
            break
        else:
            move = move + 1


    res =''
    for h in range(len(key)):
        res += chr(key[h])

print(res)
ans = task2(ciphertext, res)
</code></pre>
<p>#######################################################################</p>
<p>def filterfunc(n):<br>
upper = [chr(i) for i in range(65, 91)]<br>
lower = [chr(i) for i in range(97, 123)]<br>
return n in upper or n in lower</p>
<h1 id="split-the-text-using-different-length">split the text using different length</h1>
<p>def splitTonRow(arr,num):<br>
upper = [chr(i) for i in range(65, 91)]<br>
lower = [chr(i) for i in range(97, 123)]<br>
counter = 0<br>
res = []</p>
<pre><code>newarr = []
for i in range(len(arr)):
    if(arr[i] in upper or arr[i] in lower):
        newarr.append(arr[i])


for i in range(num):
    temp = []
    j = 0
    while(i + j * num &lt; len(newarr)):
        if(newarr[(i + j * num)] in upper or newarr[(i + j * num)] in lower ):
            temp.append(newarr[(i + j * num)])
        j = j+1
    res.append(temp)
return res
</code></pre>
<p>def fac(n):<br>
fac = []<br>
for i in range(2, n):<br>
if n % i == 0:<br>
fac.append(i)<br>
continue<br>
else:<br>
pass<br>
return fac</p>
<p>def task4(ciphertext):</p>
<pre><code>frequency = [0.082, 0.015, 0.028, 0.043, 0.127, 0.022, 0.02, 0.061, 0.07, 0.002, 0.008, 0.04, 0.024, 0.06, 0.075,
             0.019, 0.001, 0.06, 0.063, 0.091, 0.028, 0.01, 0.023, 0.001, 0.02, 0.001]
upper = [chr(i) for i in range(65, 91)]
lower = [chr(i) for i in range(97, 123)]
flag = 0
isrepeat = findrepeat(ciphertext)
facnum = 0
if(len(isrepeat)&gt;0):
    facnum = fac(isrepeat[2]-isrepeat[1])

treeshakefac = []
for j in range(len(facnum)):
    if(facnum[j]&lt;=100):
        treeshakefac.append(facnum[j])

#######################################################################
possible = []
if(len(treeshakefac)&gt;=2):
    flag = 1
    for length in treeshakefac:
        total = 0
        cipherCounter = 0
        for i in range(len(ciphertext)):
            if (ciphertext[i] in upper or ciphertext[i] in lower):
                cipherCounter = cipherCounter + 1
        key = []
        for start in range(length):
            key.append(0)
        charShowTime = {}
        splitedText = splitTonRow(ciphertext, length)

        #######################################################################

        for i in range(length):
            onecipher = splitedText[i]
            cipherCounter = 0
            for n in range(len(onecipher)):
                if (onecipher[n] in upper or onecipher[n] in lower):
                    cipherCounter = cipherCounter + 1

            move = 0
            resmove = 0
            target = 0.067
            min = 1
            while (1):
                M = 0
                position = 65 + move
                charShowTime = {}
                for j in range(26):
                    charShowTime[chr(j + 65)] = 0

                for j in range(cipherCounter):
                    if (onecipher[j] in upper):
                        charShowTime[onecipher[j]] = charShowTime[onecipher[j]] + 1
                    elif (onecipher[j] in lower):
                        temp = onecipher[j].upper()
                        charShowTime[temp] = charShowTime[temp] + 1

                for j in range(26):
                    currentFrequency = frequency[j]
                    if (position &gt;= 91):
                        position = 65
                    f = charShowTime[chr(position)] / cipherCounter
                    M += f * currentFrequency
                    position = position + 1

                if abs(target - M) &lt; min:
                    min = abs(target - M)
                    resmove = move
                if (move &gt;= 26):
                    key[i] = resmove + 65
                    break
                else:
                    move = move + 1
            total += min + target
        total = total / length
        possible.append(total)

#######################################################################
else:
    for length in range(1,101):
        total = 0
        cipherCounter = 0
        for i in range(len(ciphertext)):
            if (ciphertext[i] in upper or ciphertext[i] in lower):
                cipherCounter = cipherCounter + 1
        key = []
        for start in range(length):
            key.append(0)
        charShowTime = {}
        splitedText = splitTonRow(ciphertext, length)

        #######################################################################

        for i in range(length):
            onecipher = splitedText[i]
            cipherCounter = 0
            for n in range(len(onecipher)):
                if (onecipher[n] in upper or onecipher[n] in lower):
                    cipherCounter = cipherCounter + 1

            move = 0
            resmove = 0
            target = 0.067
            min = 1
            while (1):
                M = 0
                position = 65 + move
                charShowTime = {}
                for j in range(26):
                    charShowTime[chr(j + 65)] = 0

                for j in range(cipherCounter):
                    if (onecipher[j] in upper):
                        charShowTime[onecipher[j]] = charShowTime[onecipher[j]] + 1
                    elif (onecipher[j] in lower):
                        temp = onecipher[j].upper()
                        charShowTime[temp] = charShowTime[temp] + 1

                for j in range(26):
                    currentFrequency = frequency[j]
                    if (position &gt;= 91):
                        position = 65
                    f = charShowTime[chr(position)] / cipherCounter
                    M += f * currentFrequency
                    position = position + 1

                if abs(target - M) &lt; min:
                    min = abs(target - M)
                    resmove = move
                if (move &gt;= 26):
                    key[i] = resmove + 65
                    break
                else:
                    move = move + 1
            total += min+target
        total = total/length
        possible.append(total)

minNumber = 1
keylength = 0
if(flag ==1):
    for item in range(len(possible)):
        if abs(possible[item] - 0.067) &lt; minNumber:
            minNumber = possible[item] -0.067
            keylength = item
    print(treeshakefac[keylength])
    task3(ciphertext,treeshakefac[keylength])
else:
    for item in range(len(possible)):
        if abs(possible[item] - 0.067) &lt; minNumber:
            minNumber = possible[item] -0.067
            keylength = item
    print(keylength+1)
    task3(ciphertext,keylength+1)
</code></pre>
<p>def findrepeat(S):<br>
upper = [chr(i) for i in range(65, 91)]<br>
lower = [chr(i) for i in range(97, 123)]<br>
counter = 0<br>
res = []</p>
<pre><code>newarr = []

for i in range(len(S)):
    if (S[i] in upper or S[i] in lower):
        newarr.append(S[i])
str1 = ''
str1 = str1.join(newarr)

S_find = 0
res = ''
for i in range(len(str1)-4):
    temp = str1[i:i+4]
    S_find =str1.find(temp,i+4)
    if(S_find&gt;0):
        res = [temp,i,S_find]
        break
return res
</code></pre>
<p>if <strong>name</strong> == '<strong>main</strong>':<br>
plaintext = &quot;IMTIANHAOXIHAHAYOUMOTHERFUCKER&quot;<br>
key = &quot;CRYPOTO&quot;<br>
ciphertext = input()<br>
#length = 13<br>
# task1(plaintext,key)<br>
task4(ciphertext)<br>
#findrepeat(ciphertext)</p>
<!-- more -->

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#split-the-text-using-different-length">split the text using different length</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://TianhaoXi.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
