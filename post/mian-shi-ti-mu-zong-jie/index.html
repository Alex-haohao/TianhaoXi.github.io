<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>面试题目总结 | Alex个人博客</title>
<link rel="shortcut icon" href="https://TianhaoXi.github.io/favicon.ico?v=1599012674304">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://TianhaoXi.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="面试题目总结 | Alex个人博客 - Atom Feed" href="https://TianhaoXi.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="说一下redux的几个概念：
redux把应用的所有状态集中在一起，这样可在应用越来越大、越来越复杂时方便管理
redux主要包括一下几个方法：
createStore()      // 创建store
getState()       ..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://TianhaoXi.github.io">
  <img class="avatar" src="https://TianhaoXi.github.io/images/avatar.png?v=1599012674304" alt="">
  </a>
  <h1 class="site-title">
    Alex个人博客
  </h1>
  <p class="site-description">
    学习，分享，进步
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/TianhaoXi" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              面试题目总结
            </h2>
            <div class="post-info">
              <span>
                2020-08-17
              </span>
              <span>
                22 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="说一下redux的几个概念"><strong>说一下redux的几个概念：</strong></h1>
<p>redux把应用的所有状态集中在一起，这样可在应用越来越大、越来越复杂时方便管理<br>
redux主要包括一下几个方法：<br>
createStore()      // 创建store<br>
getState()           // 获取state<br>
dispatch()          // 分发action<br>
subscribe()       // 订阅store<br>
combineReducers //合并多个reducer<br>
需要知道 redux 不能直接更改 state ，而是通过dispatch（分发）action（描述此次改动的细节）来创建一个新的state ，这样有利于跟踪每一次改动。<br>
reducer 就像一个处理器，而action像一个指令<br>
reducer接受 action ，根据action的type来确定需要执行的更新操作。<br>
在发生更新时便会触发所有已经subscribe的函数，通常这些函数用以更新UI 层。<br>
Provider 把根组件包裹起来，将store注入整个应用中。这样就不用通过props把store一级一级地往下传。<br>
connect 用以构造 容器组件 。connect可映射state和dispatch到容器组件的props中， 然后便能在UI组件中显示state数据，或者dispatch action<br>
connect后就不需要再写subscribe来操作更新了</p>
<h1 id="函数的this指向">函数的this指向</h1>
<p>全局函数的this都是指向的window。<br>
当一个函数并非一个对象的属性时，那么它就是被当做函数来调用的。在此种模式下，this被绑定为全局对象，在浏览器环境下就是window对象<br>
当函数被保存为一个对象的属性时，它就可称为这个对象的方法。当一个方法被调用时，this被绑定到这个对象上。如果调用表达式包含一个提取属性的动作（. 或 []），那么它被称为方法调用<br>
构造函数调用模式<br>
如果在一个函数前面加上new关键字来调用，那么就会创建一个连接到该函数的prototype成员的新对象，同时，this会被绑定到这个新对象上。这种情况下，这个函数就可以成为此对象的构造函数。</p>
<h1 id="进程和线程">进程和线程</h1>
<p>一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。<br>
一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。<br>
互斥锁&quot;（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。<br>
内存区域，只能供给固定数目的线程使用。<br>
进程具有的特征：<br>
动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；<br>
并发性：任何进程都可以同其他进行一起并发执行；<br>
独立性：进程是系统进行资源分配和调度的一个独立单位；<br>
结构性：进程由程序，数据和进程控制块三部分组成<br>
线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；<br>
进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；</p>
<p>内核会为系统中每一个进程维护一份相互独立的页映射表。。页映射表的基本原理是将程序运行过程中需要访问的一段虚拟内存空间通过页映射表映射到一段物理内存空间上，这样CPU访问对应虚拟内存地址的时候就可以通过这种查找页映射表的机制访问物理内存上的某个对应的地址。“页（page）”是虚拟内存空间向物理内存空间映射的基本单元。</p>
<h1 id="generator">generator</h1>
<p>generator由function*定义<br>
调用generator对象有两个方法，一是不断地调用generator对象的next()方法：<br>
next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。<br>
for ... of循环迭代generator对象<br>
异步回调代码变成“同步”代码</p>
<h1 id="http请求的四个部分">HTTP请求的四个部分：</h1>
<p>1、HTTP请求的方法或者动作，GET或者POST等<br>
Request Method: POST<br>
请求地址URL（你连URL地址都没有你请求什么）<br>
Request URL:https://contract-web.uat.yixincapital.com/contract2.0-web/<br>
请求头，包含客户端环境信息，身份验证信息<br>
客户端浏览器请求Header(HTTP request header)<br>
Accept 可接受的内容类型<br>
Accept-Language 语言<br>
Accept-Encoding 可接受的压缩类型 gzip,deflate<br>
Accept-Charset 可接受的内容编码 UTF-8,*<br>
Content-Type: application/x-www-form-urlencoded; charset=UTF-8(内容类型，这种表示key-value形式，下方有from data)<br>
Content-Type: application/json;charset=utf-8（内容类型，这种表示json形式，请求体为json形式，没有from data<br>
Cookie:JSESSIONID=F06E92B6119E19B000BC43F40984A575（cookie）<br>
Host  请求的域名<br>
Origin:https://contract-web.uat.yixincapital.com（最初请求从哪个网站跳过来的）<br>
Referer:https://contract-web.uat.yixincapital.com/contract2.0-web/contract2.0-vue//contractManage/index.html（从哪个网站跳过来的）<br>
User-Agent 浏览器端浏览器型号和版本<br>
X-Requested-With:XMLHttpRequest（ 如果 requestedWith 为 null，则为同步请求。 如果 requestedWith 为 XMLHttpRequest 则为 Ajax 请求）</p>
<p>请求体，即请求正文，请求正文可以包含客户提交的查询字符，表单信息等等</p>
<p>二、一个HTTP响应由三部分组成：<br>
1、一个数字与文字组成的状态码，用来显示请求成功失败信息<br>
Status Code:  200 OK<br>
2、响应头，响应头与请求头包含许多有用信息，例如：服务器类型、日期时间、内容类型和长度等。<br>
服务器端的响应Header(response header)<br>
Connection:keep-alive（ 针对该连接所预期的选项）<br>
Content-Disposition:inline;filename=f.txt（ 对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。）<br>
Content-Type:application/json;charset=UTF-8（ 当前内容的MIME类型）<br>
Date:Wed, 07 Nov 2018 09:33:39 GMT*（ 此条消息被发送时的日期和时间(以RFC 7231中定义的&quot;HTTP日期&quot;格式来表示)）<br>
Server:Tengine（ 服务器的名称）<br>
Transfer-Encoding: chunked（ 用表示实体传输给用户的编码形式。包括：chunked、compress、 deflate、gzip、identity。）<br>
3、响应体，响应正文</p>
<p>三、HTTP常见状态码：<br>
1xx	Informational（信息性状态码）	接受的请求正在处理<br>
2xx	Success（成功状态码）	请求正常处理完毕<br>
3xx	Redirection（重定向）	需要进行附加操作以完成请求<br>
4xx	Client error（客户端错误）	客户端请求出错，服务器无法处理请求<br>
5xx	Server Error（服务器错误）	服务器处理请求出错</p>
<p>200 OK：表示从客户端发送给服务器的请求被正常处理并返回；<br>
202：表示服务器已经接受了请求，但是还没有处理，而且这个请求最终会不会处理还不确定<br>
204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）；<br>
206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。</p>
<p>301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；<br>
302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；<br>
301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）<br>
303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；<br>
302与303的区别：后者明确表示客户端应当采用GET方式获取资源<br>
304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；<br>
307 Temporary Redirect：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；</p>
<p>400 Bad Request：表示请求报文中存在语法错误；<br>
401 Unauthorized：未经许可，需要通过HTTP认证；<br>
403 Forbidden：服务器拒绝该次访问（访问权限出现问题）<br>
404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</p>
<p>500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；<br>
503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</p>
<h1 id="content-type">content-type</h1>
<p>text/plain 　　　　　　　　文本类型<br>
text/css  　　　　　　　　 css类型<br>
text/html 　　 　　　　　　html类型<br>
application/x-javascript 　　js类型<br>
application/json　　　　　 json类型<br>
image/png jpg gif　　　　　 image/*</p>
<h1 id="断点续传">断点续传</h1>
<p>HTTP1.1 协议（RFC2616）开始支持获取文件的部分内容，这为并行下载以及断点续传提供了技术支持。它通过在 Header 里两个参数实现的，客户端发请求时对应的是 Range ，服务器端响应时对应的是 Content-Range。<br>
Range:<br>
用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：<br>
HTTP/1.1 206 Partial Content（使用断点续传方式）</p>
<h1 id="http如何控制请求的数量">http如何控制请求的数量</h1>
<p>TTP 连接产生的开销<br>
域名解析–TCP 连接–发送请求–等待–下载资源–解析时间<br>
（减少开销：DNS缓存、Keep-Alive）<br>
合并脚本和样式表，使用外部的 js 和 css 文件引用的方式，因为这要比直接写在页面中性能要更好一点；独立的一个 js 比用多个 js 文件组成的页面载入要快 38%<br>
图片使用 Base64 编码减少页面请求数。采用 Base64 的编码方式将图片直接嵌入到网页中，而不是从外部载入。（高版本浏览器解析）<br>
首屏渲染---文件样式布局主要由js文件决定，合并之后的js文件变大，会导致首屏渲染很慢<br>
缓存失效---合并之后，修改了一个js文件，导致整个合并的代码重新加载，缓存失效</p>
<p>#从输入url到页面展现发生了什么？其中在页面渲染以及网络请求响应的性能优化方面，我们分别可以做哪些优化工作？<br>
请求页面<br>
1、dns解析<br>
- 先在本地host查找<br>
- 到浏览器dns缓存查找<br>
- 到根域名服务器查找<br>
- 找主域名服务器查找<br>
- 返回ip地址<br>
2、浏览器缓存<br>
- 强缓存maxAge未过时直接读取本地磁盘缓存，无需建立连接<br>
- 协商缓存if-modify-since --&gt; etag （优先级高）<br>
3、没有缓存，建立tcp连接<br>
- 三次握手 syn -&gt; syn+ack -&gt; fin<br>
- 建立SSL通信，客户端携带随机数，支持的加密算法列表请求443端口 -&gt; 服务端返回数字证书+公钥+随机数b -&gt; 客户端验证证书有效性生成随机数c，用某种加密算法根据abc生成对称密钥，并返回给服务端 -&gt; 服务端私钥解密，得到对称密钥，然后双方使用对称密钥通信<br>
// - 复杂请求，先发起option请求检验服务可用性<br>
- 接收数据包（请求头，请求行，请求体）根据content-type进行解码，根据不同资源类型进行不同的加载策略<br>
- 四次挥手 syn -&gt; syn + ack -&gt; fin -&gt; ack + fin<br>
4、浏览器渲染<br>
- 浏览器主进程通知渲染进程可以开始渲染了<br>
- 渲染进程接收到垂直同步信号，通知主线程<br>
- 主线程先进行渲染的前置操作，清空当前的所有微任务，之后触发requestAnimationFrame，进入渲染阶段<br>
- 构建dom树 + css renderer -&gt; 得到layout树<br>
-根据图层生成规则，并计算节点位置，生成layer树<br>
- 通知合成线程，layer树准备完毕<br>
- 合成线程进行分块和光栅化的操作<br>
- 通知gpu可以开始进行绘制了<br>
- gpu调用显示器提供的DirectX api，ldp，aldp不同策略进行得到色彩页面显示<br>
- （中间会穿插css的加载，js的执行，defer，async等不同策略）</p>
<p>输入url按下回车之后，浏览器会去浏览器缓存中寻找该url的ip；没有的话去系统缓存中找，还是没有的话去路由器缓存中寻找；再没有就去系统host文件中找，还是没有最后只能去请求dns服务器，然后dns给一个ip给浏览器；浏览器根据这个ip地址，将请求信息，请求说明和请求参数等封成一个tcp包，由传输层，到网络层，到数据链路层到物理层，传送给服务器，服务器解析这个tcp包将对应的页面文件返回。浏览器根据html文件生成dom树，根据css文件生成cssom树，然后合并这两棵树生成渲染树，然后渲染页面并且展示。要注意的是，当浏览器解析html文件时候如果遇到了内联或者外联的js代码，会暂停dom树的生成，等js代码执行完成之后，才能继续生成树并渲染。<br>
其中在页面渲染以及网络请求响应的性能优化方面，我们可以做的优化工作有：1.js代码写在页面渲染完成之后避免阻塞渲染    2.cdn并发，资源压缩，减少请求次数    3.预加载或者懒加载</p>
<h1 id="拥塞控制">拥塞控制</h1>
<p>TCP的四种拥塞控制算法<br>
1.慢开始<br>
2.拥塞控制<br>
3.快重传<br>
4.快恢复<br>
拥塞控制：<br>
https://www.cnblogs.com/kubidemanong/p/9973757.html<br>
流量控制：<br>
https://www.cnblogs.com/kubidemanong/p/9987810.html<br>
增长阶段称之为慢启动，线性增长阶段称之为拥塞避免</p>
<p>拥塞控制与网络的拥堵情况相关联，而流量控制与接收方的缓存状态相关联。</p>
<h1 id="cookies-localstorage-sessionstorage">cookies localStorage sessionStorage</h1>
<p>Cookie 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效<br>
每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题<br>
服务器像客户端发送cookie<br>
浏览器将cookie保存<br>
之后每次http请求浏览器都会将cookie发送给服务器端 Set-Cookie中设置</p>
<p>#tcp的连接<br>
https://blog.csdn.net/weixin_44907813/article/details/90444151</p>
<p><img src="https://TianhaoXi.github.io/post-images/1597643981310.png" alt="" loading="lazy"><br>
<img src="https://TianhaoXi.github.io/post-images/1597644169819.png" alt="" loading="lazy"></p>
<h1 id="跨域和解决方法">跨域和解决方法</h1>
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>
<p>jsonp:<br>
同源策略请求: ajax fetch<br>
script img link  标签不存在跨域<br>
jsonp只能处理get请求</p>
<p>clint:<br>
$.ajax({<br>
url : 'http://localhost:3002/api/data1',<br>
dataType : 'jsonp',<br>
type : 'get',<br>
success : function(res){<br>
console.log(res);<br>
},<br>
error: function() {<br>
console.log(&quot;fail&quot;)<br>
}<br>
});</p>
<p>server:<br>
let routerJsonp = new Router();<br>
routerJsonp.get('/data1', async (ctx) =&gt; {<br>
let cb = ctx.request.query.callback;<br>
ctx.type = 'text/javascript'<br>
let returnData = {<br>
success: true,<br>
data: {<br>
text: 'this is a jsonp api',<br>
time: new Date().getTime(),<br>
}<br>
}<br>
// jsonp的script字符串<br>
let jsonpStr = <code>;${callbackName}(${JSON.stringify(returnData)})</code><br>
ctx.body = jsonpStr<br>
})</p>
<p>router.get('/data1', async (ctx) =&gt; {<br>
let cb = ctx.request.query.callback;<br>
ctx.type = 'text';<br>
ctx.body = cb + '(' + '&quot;数据&quot;' + ')';<br>
})</p>
<p>CORS：<br>
axios.get('http://127.0.0.01:3001/user/list').then(res=&gt;{<br>
console.log(res)<br>
})</p>
<p>const cors = require('koa2-cors');<br>
app.use(async (ctx, next) =&gt; {<br>
// 允许来自所有域名请求<br>
ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);<br>
// 这样就能只允许 http://localhost:8080 这个域名的请求了<br>
// ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8080&quot;);</p>
<pre><code>// 设置所允许的HTTP请求方法
ctx.set(&quot;Access-Control-Allow-Methods&quot;, &quot;OPTIONS, GET, PUT, POST, DELETE&quot;);

// 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段.
ctx.set(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with, accept, origin, content-type&quot;);

// 服务器收到请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。

// Content-Type表示具体请求中的媒体类型信息
ctx.set(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);

// 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。
// 当设置成允许请求携带cookie时，需要保证&quot;Access-Control-Allow-Origin&quot;是服务器有的域名，而不能是&quot;*&quot;;
ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);

// 该字段可选，用来指定本次预检请求的有效期，单位为秒。
// 当请求方法是PUT或DELETE等特殊方法或者Content-Type字段的类型是application/json时，服务器会提前发送一次请求进行验证
// 下面的的设置只本次验证的有效时间，即在该时间段内服务端可以不用进行验证
ctx.set(&quot;Access-Control-Max-Age&quot;, 300);

/*
CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：
    Cache-Control、
    Content-Language、
    Content-Type、
    Expires、
    Last-Modified、
    Pragma。
*/
// 需要获取其他字段时，使用Access-Control-Expose-Headers，
// getResponseHeader('myData')可以返回我们所需的值
ctx.set(&quot;Access-Control-Expose-Headers&quot;, &quot;myData&quot;);

await next();
</code></pre>
<p>})</p>
<p>3 http proxy:</p>
<p>const proxy = require('http-proxy-middleware');<br>
module.exports = function (app) {<br>
app.use(proxy('/api', { target: 'http://localhost:3002/' }));<br>
};</p>
<p>CSRF：<br>
<img src="https://TianhaoXi.github.io/post-images/1597663497671.jpg" alt="" loading="lazy"></p>
<h1 id="回流和重绘">回流和重绘</h1>
<p>https://www.jianshu.com/p/e081f9aa03fb<br>
当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。<br>
当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。<br>
https://blog.csdn.net/binlety/article/details/81390346<br>
https://blog.csdn.net/weixin_30289831/article/details/97202752?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param<br>
https://blog.csdn.net/qq_36360463/article/details/105129688?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</p>
<h1 id="一次性加载一万个标签">一次性加载一万个标签</h1>
<p>document.createDocumentFrament</p>
<script>
	var container = document.getElementById('container')
	var fragment = document.createDocumentFragment()
	for(let i = 0; i < 10000; i++){
		let li = document.createElement('li')
		li.innerHTML = 'hello world'
	    fragment.appendChild(li)
	}
	container.appendChild(fragment);
</script>
<p>前端工程化:<br>
模块化<br>
简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。只有这样，才有多人协作的可能。<br>
组件化</p>
<h1 id="节流和防抖">节流和防抖</h1>
<p>对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。<br>
https://segmentfault.com/a/1190000018428170</p>
<p>function debounce(func,wait){<br>
let timer;</p>
<pre><code>return function(){
    clearTimeout(timer);
    timer = setTimeout(func,wait)
}
</code></pre>
<p>}</p>
<p>function real(){<br>
console.log(&quot;123&quot;);<br>
}</p>
<p>function throttle(func,wait,mustrun){<br>
let timeout,starttime = new Date();</p>
<pre><code>return ()=&gt;{
    let currenttime = new Date();
    clearTimeout(timeout)
    if(currenttime-starttime&gt;mustrun){
        func.apply(this,arguments)
        starttime = currenttime
    }
    else{
        timeout = setTimeout(func,wait)
    }
}
</code></pre>
<p>}</p>
<p>window.addEventListener(&quot;scroll&quot;,throttle(real,1000,1000))</p>
<p>#清除浮动<br>
方法一：使用带clear属性的空元素<br>
在浮动元素后使用一个空元素如<div class="clear"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用<br class="clear" />或<hr class="clear" />来进行清理。</p>
<p>.clearfix:after{/<em>伪元素是行内元素 正常浏览器清除浮动方法</em>/<br>
content: &quot;&quot;;<br>
display: block;<br>
height: 0;<br>
clear:both;<br>
visibility: hidden;<br>
}</p>
<p>BFC:<br>
三、触发 BFC<br>
只要元素满足下面任一条件即可触发 BFC 特性：<br>
body 根元素<br>
浮动元素：float 除 none 以外的值<br>
绝对定位元素：position (absolute、fixed)<br>
display 为 inline-block、table-cells、flex<br>
overflow 除了 visible 以外的值 (hidden、auto、scroll)</p>
<h1 id="css居中">css居中</h1>
<p>行内水平 text-align:center</p>
<p>block居中:<br>
display:flex;<br>
align-items: center;<br>
justify-content:center;</p>
<p>position:absolute;<br>
left:50%;<br>
top:50%;<br>
transform: translate(-50%,-50%);</p>
<p>#左边固定宽度，右边自适应<br>
1.<br>
.left{<br>
float: left;<br>
width: 200px;<br>
background: red;<br>
}<br>
.right{<br>
margin-left: 200px;<br>
background: blue;<br>
}</p>
<ol start="2">
<li>
<p>.right{<br>
overflow: hidden;<br>
background: blue;<br>
}</p>
</li>
<li>
<p>flex:<br>
.wrapper{<br>
display: flex;<br>
}<br>
.left,.right{<br>
height: 100px;<br>
}<br>
.left{<br>
width: 200px;<br>
background: red;<br>
}<br>
.right{<br>
flex: 1;<br>
background: blue;<br>
}</p>
</li>
</ol>
<h1 id="白屏优化">白屏优化</h1>
<p>https://blog.csdn.net/PHPxiaoxuesheng/article/details/100935993</p>
<p>#强缓存与协商缓存<br>
https://www.jianshu.com/p/9c95db596df5<br>
强缓存<br>
到底什么是强缓存？强在哪？其实强是强制的意思。当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制，具体表现为：<br>
respone header 的cache-control，常见的设置是max-age public private no-cache no-store等<br>
如果cahe-control:max-age=315360000,public再加个immutable的话，就算用户刷新页面，浏览器也不会发起请求去服务，浏览器会直接从本地磁盘或者内存中读取缓存并返回200状态</p>
<h1 id="浏览器的线程">浏览器的线程</h1>
<p>https://segmentfault.com/a/1190000013083967</p>
<h1 id="deepclone">deepClone</h1>
<p>function deepClone(target){<br>
let result;<br>
if(typeof result === 'object'){<br>
if(target instanceof Array){<br>
result = [];<br>
for(let i =0;i&lt;tartget.length;i++){<br>
result.push(deepClone(target[i]))<br>
}<br>
}<br>
else if(target ===null){<br>
result = null;<br>
}<br>
else if( target.<strong>proto</strong>.constructor ===RegExp){<br>
result = target;<br>
}<br>
else{<br>
result = {};<br>
for(let i in target){<br>
result[i] = deepClone(target[i])<br>
}<br>
}<br>
}<br>
else{<br>
result = target;<br>
}</p>
<pre><code>return result;
</code></pre>
<p>}</p>
<h1 id="垃圾回收机制">垃圾回收机制</h1>
<p>https://segmentfault.com/a/1190000018605776?utm_source=tag-newest</p>
<h1 id="cors-简单-复杂请求">cors 简单 复杂请求</h1>
<p>https://www.cnblogs.com/qunxiadexiaoxiangjiao/p/9446956.html</p>
<p>#原生jsonP</p>
<script>
let response = ""
function jsonp_callback(data){
    console.log(data)
    response = data;
}
</script>
<script src="http://localhost:3002/api/comment?callback=jsonp_callback_function"">
</script>
<p>#bind curry<br>
Function.prototype.bind = function (context) {<br>
var _this = this<br>
var args = Array.prototype.slice.call(arguments, 1)</p>
<pre><code>return function() {
    return _this.apply(context, args)
}
</code></pre>
<p>}</p>
<p>mvc mvvm<br>
M、V、C<br>
Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。<br>
通常模型对象负责在数据库中存取数据。<br>
View（视图）：是应用程序中处理数据显示的部分。<br>
通常视图是依据模型数据创建的。<br>
Controller（控制器）：是应用程序中处理用户交互的部分。<br>
通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。<br>
mvvm:<br>
View的变动，自动反映在 ViewModel，反之亦然。</p>
<h1 id="事件委托">事件委托</h1>
<p>window.onload = function(){<br>
　　var oUl = document.getElementById(&quot;ul1&quot;);<br>
　　oUl.onclick = function(ev){<br>
　　　　var ev = ev || window.event;<br>
　　　　var target = ev.target || ev.srcElement;<br>
　　　　if(target.nodeName.toLowerCase() == 'li'){<br>
　 　　　　　　 alert(123);<br>
　　　　　　　  alert(target.innerHTML);<br>
　　　　}<br>
　　}<br>
}</p>
<h1 id="箭头函数">箭头函数：</h1>
<p>ES6 增加了箭头函数，基本语法为<br>
let func = value =&gt; value;</p>
<p>相当于</p>
<p>let func = function (value) {</p>
<p>return value;</p>
<p>};</p>
<p>箭头函数与普通函数的区别在于：</p>
<p>1、箭头函数没有this，所以需要通过查找作用域链来确定this的值，这就意味着如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this，</p>
<p>2、箭头函数没有自己的arguments对象，但是可以访问外围函数的arguments对象</p>
<p>3、不能通过new关键字调用，同样也没有new.target值和原型</p>
<p>#简单讲一讲ES6的一些新特性</p>
<p>ES6在变量的声明和定义方面增加了let、const声明变量，有局部变量的概念，赋值中有比较吸引人的结构赋值，同时ES6对字符串、 数组、正则、对象、函数等拓展了一些方法，如字符串方面的模板字符串、函数方面的默认参数、对象方面属性的简洁表达方式，ES6也 引入了新的数据类型symbol，新的数据结构set和map,symbol可以通过typeof检测出来，为解决异步回调问题，引入了promise和 generator，还有最为吸引人了实现Class和模块，通过Class可以更好的面向对象编程，使用模块加载方便模块化编程，当然考虑到 浏览器兼容性，我们在实际开发中需要使用babel进行编译<br>
重要的特性：</p>
<p>块级作用域：ES5只有全局作用域和函数作用域，块级作用域的好处是不再需要立即执行的函数表达式，循环体中的闭包不再有问题</p>
<p>rest参数：用于获取函数的多余参数，这样就不需要使用arguments对象了，</p>
<p>promise:一种异步编程的解决方案，比传统的解决方案回调函数和事件更合理强大</p>
<p>模块化：其模块功能主要有两个命令构成，export和import，export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能</p>
<p>文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。</p>
<p>webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源</p>
<p>redux<br>
在组件化的应用中，会有着大量的组件层级关系，深嵌套的组件与浅层父组件进行数据交互，变得十分繁琐困难。而redux，站在一个服务级别的角度，可以毫无阻碍地将应用的状态传递到每一个层级的组件中。redux就相当于整个应用的管家。<br>
提供 getState() 方法获取 state；<br>
提供 dispatch(action) 方法更新 state；<br>
通过 subscribe(listener) 注册监听器;<br>
React 是一个用于构建用户界面的 JAVASCRIPT 库。React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）<br>
React特点有：</p>
<p>1.声明式设计 −React采用声明范式，可以轻松描述应用。</p>
<p>2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。</p>
<p>3.灵活 −React可以与已知的库或框架很好地配合。</p>
<p>4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。</p>
<p>5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。</p>
<p>6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。<br>
在React中，数据是单向流动的，是从上向下的方向，即从父组件到子组件的方向。<br>
state和props是其中重要的概念，如果顶层组件初始化props，那么React会向下遍历整颗组件树，重新渲染相关的子组件。其中state表示的是每个组件中内部的的状态，这些状态只在组件内部改变。<br>
把组件看成是一个函数，那么他接受props作为参数，内部由state作为函数的内部参数，返回一个虚拟dom的实现。<br>
diff算法，diff算法有三种优化形式：<br>
tree diff：将新旧两颗DOM树按照层级遍历，只对同级的DOM节点进行比较，即同一父节点下的所有子节点，当发现节点已经不存在，则该节点及其子节点会被完全删除，不会进一步比较</p>
<p>component diff：不同组件之间的对比，如果组件类型相同，暂不更新，否则删除旧的组件，再创建一个新的组件，插入到删除组件的位置</p>
<p>element diff:在类型相同的组件内，再继续对比组件内部的元素，</p>
<p>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。 经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。 在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。 在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p>
<p>单例模式：在它的核心结构中值包含一个被称为单例的特殊类。一个类只有一个实例，即一个类只有一个对象实例。<br>
工厂模式：在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p>发布订阅模式：在软件架构中，发布订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。</p>
<h1 id="前端性能优化">前端性能优化</h1>
<p>前端性能优化有七大手段：减少请求数量，减少资源大小，优化网络连接，优化资源加载，减少重绘回流，使用性能更好的API和构建优化<br>
减少请求数量：通过减少重定向，使用缓存，不适用CSS@import，避免使用空的src和href等手段</p>
<p>减少资源大小：通过压缩HTML，CSS，JS，图片，此外在安卓下可以使用webp格式的图片，它具有更优的图像数据压缩算法，能带来更小的图片体积，还可以开启gzip,gzip编码是以后总用来改进web应用程序性能的技术，</p>
<p>优化网络连接：使用CDN，使用DNS预解析，并行连接，</p>
<p>优化资源加载，通过优化资源加载位置和时机，使用资源预加载preload和资源预读取prefetch</p>
<p>减少重绘回流，1：避免使用层级较深的CSS选择器，以提高CSS渲染效率2、避免使用CSS表达式，3、给元素适当的定义高度或最小高度，否则元素的动态内容载入时，会出现页面晃动，造成回流，4、不要使用table布局，5、能用CSS实现的效果，尽量使用CSS而不用JS实现</p>
<p>使用性能更好的api,</p>
<p>随机创造hex<br>
let hex = ()=&gt;{<br>
return res = &quot;#&quot;+Math.floor(Math.random()*0xffffff).toString(16)<br>
}</p>
<p>hex2rgb<br>
function hexToRgb(hex) {<br>
return &quot;rgb(&quot; + parseInt(&quot;0x&quot; + hex.slice(1, 3)) + &quot;,&quot; + parseInt(&quot;0x&quot; + hex.slice(3, 5)) + &quot;,&quot; + parseInt(&quot;0x&quot; + hex.slice(5, 7))<br>
}</p>
<p>使用new调用函数时，会执行[[construct]]方法：<br>
(1) 在内存中创建一个继承自 fn.prototype 的新对象<br>
(2) 把函数体的this指向新对象，并执行函数体。<br>
(3) 默认返回新对象。如果构造函数指定的返回值为复杂类型，会覆盖掉默认返回值。</p>
<p>Function.prototype.mybine = function(context){<br>
let self = this;<br>
return function(){<br>
self.apply(context,arguments)<br>
}<br>
}</p>
<p>Array.prototype.myfilter = function(fn){<br>
let array = [];<br>
for(let i=0;i&lt;this.length;i++){<br>
let item = this[i];<br>
if(fn(item,i,this)){<br>
array.push(this[i])<br>
}<br>
}<br>
return array;<br>
}</p>
<p>Array.prototype.fakeMap = function(fn) {<br>
let arr = this;<br>
let temp = [];<br>
for(let i=0;i&lt;arr.length;i++){<br>
let result = fn(arr[i],i,arr);<br>
temp.push(result);<br>
}<br>
return temp;<br>
}</p>
<h1 id="css-position有几种属性">CSS position有几种属性</h1>
<p>position: static; 的元素不会被特殊的定位<br>
fixed：元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动，相当一个壁纸标签一样一动不动像镶嵌在屏幕里一样，<br>
相对定位，是相对于其原本的位置来定位的。元素仍处于文档流中，定位是相对于原本自身的位置<br>
absolute：元素会脱离文档流，定位是相对于离它最近的且不是static定位的父元素而言，若该元素没有设置宽度，则宽度由元素里面的内容决定，且宽度不会影响父元素，定位为absolution后，原来的位置相当于是空的，下面的的元素会来占据。<br>
sticky：<br>
必须制定 top、bottom 、left 、 right 4个值之一，否则只会处于相对定位；<br>
父元素的高度不能低于sticky 元素的高度；<br>
sticky 元素仅在其父元素内生效；</p>
<p>for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用for-in循环</p>
<p>标准盒模型 box-sizing: content-box<br>
content-box:<br>
width = content width;<br>
height = content height</p>
<p>IE盒模型 box-sizing: border-box<br>
border-box:<br>
width = border + padding + content width<br>
heigth = border + padding + content heigth</p>
<p>赋值方法 （Mutator methods）<br>
pop 和 push shift 和 unshift splice reverse sort<br>
访问方法（Accessor methods）：<br>
join slice concat</p>
<p>迭代方法（Iteration methods）<br>
forEach forEach是无法通过break来中断数组的遍历。<br>
map</p>
<p>由于继承而发生样式冲突时，最近祖先获胜（最近原则）。<br>
继承的样式和直接指定的样式冲突时，直接指定的样式获胜（最直接原则）。<br>
直接指定的样式发生冲突时，样式权值高者获胜。<br>
css选择器 权值<br>
标签选择器 1<br>
类选择器 10<br>
ID选择器 100<br>
内联样式 1000<br>
伪元素(:first-child等) 1<br>
伪类(:link等) 10<br>
可以看到，内联样式的权值&gt;&gt;ID选择器&gt;&gt;类选择器&gt;&gt;标签选择器，除此以外，后代选择器的权值为每项权值之和，比如”<br>
样式权值相同时，后者获胜。<br>
!important的样式属性不被覆盖。</p>
<h1 id="事件委托-2">事件委托</h1>
<p>window.onload = function(){<br>
　　var oUl = document.getElementById(&quot;ul1&quot;);<br>
　　oUl.onclick = function(ev){<br>
　　　　var ev = ev || window.event;<br>
　　　　var target = ev.target || ev.srcElement;<br>
　　　　if(target.nodeName.toLowerCase() == 'li'){<br>
　 　　　　　　 alert(123);<br>
　　　　　　　  alert(target.innerHTML);<br>
　　　　}<br>
　　}<br>
}</p>
<h1 id="判断数据类型">判断数据类型</h1>
<p>使用typeof操作符。<br>
　　对一个值使用 typeof 操作符可能返回下列某个字符串，返回的类型都是字符串形式。</p>
<p>(1) undefined：如果这个值未定义</p>
<p>(2) boolean：如果这个值是布尔值</p>
<p>(3) string：如果这个值是字符串</p>
<p>(4) number：如果这个值是数值</p>
<p>(5) object：如果这个值是对象或null</p>
<p>(6) function：如果这个值是函数</p>
<p>需要注意：typeof不适合用于判断是否为数组。当使用typeof判断数组和对象的时候，都会返回object。</p>
<p>instanceof<br>
　　instanceof 运算符用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上。需要区分大小写。</p>
<p>简单的来说，instanceof 用于判断一个变量是否某个对象的实例。</p>
<p>例：var arr = new Array( );</p>
<p>alert(arr instanceof Array);   // 返回true</p>
<p>需要注意的是，instanceof只能用来判断对象和函数，不能用来判断字符串和数字等。判断它是否为字符串和数字时，只会返回false。</p>
<p>constructor 属性返回对创建此对象的数组函数的引用。</p>
<p>在JavaScript中，每个具有原型的对象都会自动获得constructor属性。</p>
<p>Object.prototype.toString.call</p>
<p>时效缓存（强制缓存）：<br>
Cache-Control （低版本浏览器用的是Expires，了解即可）</p>
<p>是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。</p>
<p>private:             客户端可以缓存</p>
<p>public:              客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）</p>
<p>max-age=xxx:   缓存的内容将在 xxx 秒后失效</p>
<p>no-cache:          需要使用对比缓存来验证缓存数据</p>
<p>no-store:           所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so...基本上和它说886）</p>
<p>非时效缓存（对比缓存，用的是标识）：<br>
他用的不是时效时间max-age</p>
<p>第一次请求的时候，返回给客户端数据和缓存的信息，也就是一个特定的缓存标识</p>
<p>客户端把这个缓存标识放到缓存数据库</p>
<p>再次请求时 客户端先把缓存标识也一起发给服务端，进行对比</p>
<p>客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。</p>
<p>分为两种缓存标识</p>
<p>Etag （唯一标识）优先级更高</p>
<p>Last-Modified/If-Modified-Since  返回给客户端最后这个资源的修改时间，优先级没有Etag高</p>
<p>对比缓存标识生效不生效时，状态码200，服务端返回body和header</p>
<p>在对比缓存标识生效时，状态码为304，并且报文大小和请求时间大大减少。</p>
<p>原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。强制缓存的优先级更高，如果没失效，就直接用缓存数据库里的东西</p>
<p>如果时间已经失效了，就看用的是哪种标识（Etag服务端生成的唯一标识，还是last-modified资源最后修改时间标识）返回304就用缓存里的，返回200就返回body和新的header</p>
<p>一般来说，无论如何都会协商缓存，浏览器必备的缓存不可能没有~</p>
<p>1.3 前端性能优化的方法？<br>
（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</p>
<p>（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</p>
<p>（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</p>
<p>（4） 当需要设置的样式很多时设置className而不是直接操作style。</p>
<p>（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</p>
<p>（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</p>
<p>（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。</p>
<p>（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。</p>
<p>css常见块元素行元素及其区别<br>
答： 块 div p h1-6 hr li ul<br>
行 a img input span  br<br>
块级元素单独占一行，行元素多个占一行<br>
块级元素可以设置宽高，行元素不行<br>
行元素上下外边距内边距无效</p>
<p>css3用过哪些<br>
边框圆角、动画、transfrom</p>
<p>cookie的作用及字段属性干啥的<br>
作为一种标记，可以储存用户信息。<br>
name 名字值  expires 过期时间 path 可以访问此cookie的路径  domain 可以访问此cookie的域 httponly 是否只能通过http获取  secure 是否只通过https发送  samesite cookie是否跨站</p>
<p>.es6新特性<br>
let const 、箭头函数、map、set、...、class、promise</p>
<p>浅复制，assign，{...}<br>
12.深复制，loadsh库deepclone，json.parse(json.stringify)</p>
<p>利用id获取就是：document.getElementById(&quot;name&quot;);</p>
<p>利用class获取就是：document.getElementsByClassName(&quot;name&quot;);</p>
<p>利用标签获取就是：document.getElementsByClassTagName(&quot;name&quot;)；<br>
创建新元素，追加到已有的元素上：document.getElementById(&quot;name&quot;).createElement(“”);<br>
document.documentElement.clientWidth--获取宽度<br>
document.documentElement.clientHeight--获取高度</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
<p>箭头函数是匿名函数，不能作为构造函数，不能使用new<br>
箭头函数不能绑定arguments，取而代之用rest参数...解决</p>
<p>箭头函数的this永远指向其上下文的this，没有办改变其指向，<br>
普通函数的this指向调用它的对象<br>
箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值</p>
<p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。同名属性会替换。<br>
Object.create(prototype[,propertiesObject])<br>
Object.defineProperties(obj,props)<br>
Object.keys(obj)<br>
Object.values()<br>
Object.entries()</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E8%AF%B4%E4%B8%80%E4%B8%8Bredux%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5"><strong>说一下redux的几个概念：</strong></a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91">函数的this指向</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">进程和线程</a></li>
<li><a href="#generator">generator</a></li>
<li><a href="#http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%83%A8%E5%88%86">HTTP请求的四个部分：</a></li>
<li><a href="#content-type">content-type</a></li>
<li><a href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0">断点续传</a></li>
<li><a href="#http%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E8%AF%B7%E6%B1%82%E7%9A%84%E6%95%B0%E9%87%8F">http如何控制请求的数量</a></li>
<li><a href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">拥塞控制</a></li>
<li><a href="#cookies-localstorage-sessionstorage">cookies localStorage sessionStorage</a></li>
<li><a href="#%E8%B7%A8%E5%9F%9F%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">跨域和解决方法</a></li>
<li><a href="#%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98">回流和重绘</a></li>
<li><a href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%87%E4%B8%AA%E6%A0%87%E7%AD%BE">一次性加载一万个标签</a></li>
<li><a href="#%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96">节流和防抖</a></li>
<li><a href="#css%E5%B1%85%E4%B8%AD">css居中</a></li>
<li><a href="#%E7%99%BD%E5%B1%8F%E4%BC%98%E5%8C%96">白屏优化</a></li>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BA%BF%E7%A8%8B">浏览器的线程</a></li>
<li><a href="#deepclone">deepClone</a></li>
<li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">垃圾回收机制</a></li>
<li><a href="#cors-%E7%AE%80%E5%8D%95-%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82">cors 简单 复杂请求</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98">事件委托</a></li>
<li><a href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">箭头函数：</a></li>
<li><a href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">前端性能优化</a></li>
<li><a href="#css-position%E6%9C%89%E5%87%A0%E7%A7%8D%E5%B1%9E%E6%80%A7">CSS position有几种属性</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98-2">事件委托</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">判断数据类型</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://TianhaoXi.github.io/post/js-de-xiao-zhi-shi-dian/">
              <h3 class="post-title">
                js的小知识点
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://TianhaoXi.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
