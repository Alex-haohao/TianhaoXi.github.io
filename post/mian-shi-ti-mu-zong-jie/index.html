<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>面试题目总结 | Alex个人博客</title>
<link rel="shortcut icon" href="https://TianhaoXi.github.io/favicon.ico?v=1598661057047">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://TianhaoXi.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="面试题目总结 | Alex个人博客 - Atom Feed" href="https://TianhaoXi.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="说一下redux的几个概念：
redux把应用的所有状态集中在一起，这样可在应用越来越大、越来越复杂时方便管理
redux主要包括一下几个方法：
createStore()      // 创建store
getState()       ..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://TianhaoXi.github.io">
  <img class="avatar" src="https://TianhaoXi.github.io/images/avatar.png?v=1598661057047" alt="">
  </a>
  <h1 class="site-title">
    Alex个人博客
  </h1>
  <p class="site-description">
    学习，分享，进步
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/TianhaoXi" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              面试题目总结
            </h2>
            <div class="post-info">
              <span>
                2020-08-17
              </span>
              <span>
                22 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="说一下redux的几个概念"><strong>说一下redux的几个概念：</strong></h1>
<p>redux把应用的所有状态集中在一起，这样可在应用越来越大、越来越复杂时方便管理<br>
redux主要包括一下几个方法：<br>
createStore()      // 创建store<br>
getState()           // 获取state<br>
dispatch()          // 分发action<br>
subscribe()       // 订阅store<br>
combineReducers //合并多个reducer<br>
需要知道 redux 不能直接更改 state ，而是通过dispatch（分发）action（描述此次改动的细节）来创建一个新的state ，这样有利于跟踪每一次改动。<br>
reducer 就像一个处理器，而action像一个指令<br>
reducer接受 action ，根据action的type来确定需要执行的更新操作。<br>
在发生更新时便会触发所有已经subscribe的函数，通常这些函数用以更新UI 层。<br>
Provider 把根组件包裹起来，将store注入整个应用中。这样就不用通过props把store一级一级地往下传。<br>
connect 用以构造 容器组件 。connect可映射state和dispatch到容器组件的props中， 然后便能在UI组件中显示state数据，或者dispatch action<br>
connect后就不需要再写subscribe来操作更新了</p>
<h1 id="函数的this指向">函数的this指向</h1>
<p>全局函数的this都是指向的window。<br>
当一个函数并非一个对象的属性时，那么它就是被当做函数来调用的。在此种模式下，this被绑定为全局对象，在浏览器环境下就是window对象<br>
当函数被保存为一个对象的属性时，它就可称为这个对象的方法。当一个方法被调用时，this被绑定到这个对象上。如果调用表达式包含一个提取属性的动作（. 或 []），那么它被称为方法调用<br>
构造函数调用模式<br>
如果在一个函数前面加上new关键字来调用，那么就会创建一个连接到该函数的prototype成员的新对象，同时，this会被绑定到这个新对象上。这种情况下，这个函数就可以成为此对象的构造函数。</p>
<h1 id="进程和线程">进程和线程</h1>
<p>一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。<br>
一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。<br>
互斥锁&quot;（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。<br>
内存区域，只能供给固定数目的线程使用。<br>
进程具有的特征：<br>
动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；<br>
并发性：任何进程都可以同其他进行一起并发执行；<br>
独立性：进程是系统进行资源分配和调度的一个独立单位；<br>
结构性：进程由程序，数据和进程控制块三部分组成<br>
线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；<br>
进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；</p>
<p>内核会为系统中每一个进程维护一份相互独立的页映射表。。页映射表的基本原理是将程序运行过程中需要访问的一段虚拟内存空间通过页映射表映射到一段物理内存空间上，这样CPU访问对应虚拟内存地址的时候就可以通过这种查找页映射表的机制访问物理内存上的某个对应的地址。“页（page）”是虚拟内存空间向物理内存空间映射的基本单元。</p>
<h1 id="generator">generator</h1>
<p>generator由function*定义<br>
调用generator对象有两个方法，一是不断地调用generator对象的next()方法：<br>
next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。<br>
for ... of循环迭代generator对象<br>
异步回调代码变成“同步”代码</p>
<h1 id="http请求的四个部分">HTTP请求的四个部分：</h1>
<p>1、HTTP请求的方法或者动作，GET或者POST等<br>
Request Method: POST<br>
请求地址URL（你连URL地址都没有你请求什么）<br>
Request URL:https://contract-web.uat.yixincapital.com/contract2.0-web/<br>
请求头，包含客户端环境信息，身份验证信息<br>
客户端浏览器请求Header(HTTP request header)<br>
Accept 可接受的内容类型<br>
Accept-Language 语言<br>
Accept-Encoding 可接受的压缩类型 gzip,deflate<br>
Accept-Charset 可接受的内容编码 UTF-8,*<br>
Content-Type: application/x-www-form-urlencoded; charset=UTF-8(内容类型，这种表示key-value形式，下方有from data)<br>
Content-Type: application/json;charset=utf-8（内容类型，这种表示json形式，请求体为json形式，没有from data<br>
Cookie:JSESSIONID=F06E92B6119E19B000BC43F40984A575（cookie）<br>
Host  请求的域名<br>
Origin:https://contract-web.uat.yixincapital.com（最初请求从哪个网站跳过来的）<br>
Referer:https://contract-web.uat.yixincapital.com/contract2.0-web/contract2.0-vue//contractManage/index.html（从哪个网站跳过来的）<br>
User-Agent 浏览器端浏览器型号和版本<br>
X-Requested-With:XMLHttpRequest（ 如果 requestedWith 为 null，则为同步请求。 如果 requestedWith 为 XMLHttpRequest 则为 Ajax 请求）</p>
<p>请求体，即请求正文，请求正文可以包含客户提交的查询字符，表单信息等等</p>
<p>二、一个HTTP响应由三部分组成：<br>
1、一个数字与文字组成的状态码，用来显示请求成功失败信息<br>
Status Code:  200 OK<br>
2、响应头，响应头与请求头包含许多有用信息，例如：服务器类型、日期时间、内容类型和长度等。<br>
服务器端的响应Header(response header)<br>
Connection:keep-alive（ 针对该连接所预期的选项）<br>
Content-Disposition:inline;filename=f.txt（ 对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。）<br>
Content-Type:application/json;charset=UTF-8（ 当前内容的MIME类型）<br>
Date:Wed, 07 Nov 2018 09:33:39 GMT*（ 此条消息被发送时的日期和时间(以RFC 7231中定义的&quot;HTTP日期&quot;格式来表示)）<br>
Server:Tengine（ 服务器的名称）<br>
Transfer-Encoding: chunked（ 用表示实体传输给用户的编码形式。包括：chunked、compress、 deflate、gzip、identity。）<br>
3、响应体，响应正文</p>
<p>三、HTTP常见状态码：<br>
1xx	Informational（信息性状态码）	接受的请求正在处理<br>
2xx	Success（成功状态码）	请求正常处理完毕<br>
3xx	Redirection（重定向）	需要进行附加操作以完成请求<br>
4xx	Client error（客户端错误）	客户端请求出错，服务器无法处理请求<br>
5xx	Server Error（服务器错误）	服务器处理请求出错</p>
<p>200 OK：表示从客户端发送给服务器的请求被正常处理并返回；<br>
202：表示服务器已经接受了请求，但是还没有处理，而且这个请求最终会不会处理还不确定<br>
204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）；<br>
206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。</p>
<p>301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；<br>
302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；<br>
301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）<br>
303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；<br>
302与303的区别：后者明确表示客户端应当采用GET方式获取资源<br>
304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；<br>
307 Temporary Redirect：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；</p>
<p>400 Bad Request：表示请求报文中存在语法错误；<br>
401 Unauthorized：未经许可，需要通过HTTP认证；<br>
403 Forbidden：服务器拒绝该次访问（访问权限出现问题）<br>
404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</p>
<p>500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；<br>
503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</p>
<h1 id="content-type">content-type</h1>
<p>text/plain 　　　　　　　　文本类型<br>
text/css  　　　　　　　　 css类型<br>
text/html 　　 　　　　　　html类型<br>
application/x-javascript 　　js类型<br>
application/json　　　　　 json类型<br>
image/png jpg gif　　　　　 image/*</p>
<h1 id="断点续传">断点续传</h1>
<p>HTTP1.1 协议（RFC2616）开始支持获取文件的部分内容，这为并行下载以及断点续传提供了技术支持。它通过在 Header 里两个参数实现的，客户端发请求时对应的是 Range ，服务器端响应时对应的是 Content-Range。<br>
Range:<br>
用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：<br>
HTTP/1.1 206 Partial Content（使用断点续传方式）</p>
<h1 id="http如何控制请求的数量">http如何控制请求的数量</h1>
<p>TTP 连接产生的开销<br>
域名解析–TCP 连接–发送请求–等待–下载资源–解析时间<br>
（减少开销：DNS缓存、Keep-Alive）<br>
合并脚本和样式表，使用外部的 js 和 css 文件引用的方式，因为这要比直接写在页面中性能要更好一点；独立的一个 js 比用多个 js 文件组成的页面载入要快 38%<br>
图片使用 Base64 编码减少页面请求数。采用 Base64 的编码方式将图片直接嵌入到网页中，而不是从外部载入。（高版本浏览器解析）<br>
首屏渲染---文件样式布局主要由js文件决定，合并之后的js文件变大，会导致首屏渲染很慢<br>
缓存失效---合并之后，修改了一个js文件，导致整个合并的代码重新加载，缓存失效</p>
<p>#从输入url到页面展现发生了什么？其中在页面渲染以及网络请求响应的性能优化方面，我们分别可以做哪些优化工作？<br>
请求页面<br>
1、dns解析<br>
- 先在本地host查找<br>
- 到浏览器dns缓存查找<br>
- 到根域名服务器查找<br>
- 找主域名服务器查找<br>
- 返回ip地址<br>
2、浏览器缓存<br>
- 强缓存maxAge未过时直接读取本地磁盘缓存，无需建立连接<br>
- 协商缓存if-modify-since --&gt; etag （优先级高）<br>
3、没有缓存，建立tcp连接<br>
- 三次握手 syn -&gt; syn+ack -&gt; fin<br>
- 建立SSL通信，客户端携带随机数，支持的加密算法列表请求443端口 -&gt; 服务端返回数字证书+公钥+随机数b -&gt; 客户端验证证书有效性生成随机数c，用某种加密算法根据abc生成对称密钥，并返回给服务端 -&gt; 服务端私钥解密，得到对称密钥，然后双方使用对称密钥通信<br>
// - 复杂请求，先发起option请求检验服务可用性<br>
- 接收数据包（请求头，请求行，请求体）根据content-type进行解码，根据不同资源类型进行不同的加载策略<br>
- 四次挥手 syn -&gt; syn + ack -&gt; fin -&gt; ack + fin<br>
4、浏览器渲染<br>
- 浏览器主进程通知渲染进程可以开始渲染了<br>
- 渲染进程接收到垂直同步信号，通知主线程<br>
- 主线程先进行渲染的前置操作，清空当前的所有微任务，之后触发requestAnimationFrame，进入渲染阶段<br>
- 构建dom树 + css renderer -&gt; 得到layout树<br>
-根据图层生成规则，并计算节点位置，生成layer树<br>
- 通知合成线程，layer树准备完毕<br>
- 合成线程进行分块和光栅化的操作<br>
- 通知gpu可以开始进行绘制了<br>
- gpu调用显示器提供的DirectX api，ldp，aldp不同策略进行得到色彩页面显示<br>
- （中间会穿插css的加载，js的执行，defer，async等不同策略）</p>
<p>输入url按下回车之后，浏览器会去浏览器缓存中寻找该url的ip；没有的话去系统缓存中找，还是没有的话去路由器缓存中寻找；再没有就去系统host文件中找，还是没有最后只能去请求dns服务器，然后dns给一个ip给浏览器；浏览器根据这个ip地址，将请求信息，请求说明和请求参数等封成一个tcp包，由传输层，到网络层，到数据链路层到物理层，传送给服务器，服务器解析这个tcp包将对应的页面文件返回。浏览器根据html文件生成dom树，根据css文件生成cssom树，然后合并这两棵树生成渲染树，然后渲染页面并且展示。要注意的是，当浏览器解析html文件时候如果遇到了内联或者外联的js代码，会暂停dom树的生成，等js代码执行完成之后，才能继续生成树并渲染。<br>
其中在页面渲染以及网络请求响应的性能优化方面，我们可以做的优化工作有：1.js代码写在页面渲染完成之后避免阻塞渲染    2.cdn并发，资源压缩，减少请求次数    3.预加载或者懒加载</p>
<h1 id="拥塞控制">拥塞控制</h1>
<p>TCP的四种拥塞控制算法<br>
1.慢开始<br>
2.拥塞控制<br>
3.快重传<br>
4.快恢复<br>
拥塞控制：<br>
https://www.cnblogs.com/kubidemanong/p/9973757.html<br>
流量控制：<br>
https://www.cnblogs.com/kubidemanong/p/9987810.html<br>
增长阶段称之为慢启动，线性增长阶段称之为拥塞避免</p>
<p>拥塞控制与网络的拥堵情况相关联，而流量控制与接收方的缓存状态相关联。</p>
<h1 id="cookies-localstorage-sessionstorage">cookies localStorage sessionStorage</h1>
<p>Cookie 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效<br>
每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题<br>
服务器像客户端发送cookie<br>
浏览器将cookie保存<br>
之后每次http请求浏览器都会将cookie发送给服务器端 Set-Cookie中设置</p>
<p>#tcp的连接<br>
https://blog.csdn.net/weixin_44907813/article/details/90444151</p>
<p><img src="https://TianhaoXi.github.io/post-images/1597643981310.png" alt="" loading="lazy"><br>
<img src="https://TianhaoXi.github.io/post-images/1597644169819.png" alt="" loading="lazy"></p>
<h1 id="跨域和解决方法">跨域和解决方法</h1>
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>
<p>jsonp:<br>
同源策略请求: ajax fetch<br>
script img link  标签不存在跨域<br>
jsonp只能处理get请求</p>
<p>clint:<br>
$.ajax({<br>
url : 'http://localhost:3002/api/data1',<br>
dataType : 'jsonp',<br>
type : 'get',<br>
success : function(res){<br>
console.log(res);<br>
},<br>
error: function() {<br>
console.log(&quot;fail&quot;)<br>
}<br>
});</p>
<p>server:<br>
let routerJsonp = new Router();<br>
routerJsonp.get('/data1', async (ctx) =&gt; {<br>
let cb = ctx.request.query.callback;<br>
ctx.type = 'text/javascript'<br>
let returnData = {<br>
success: true,<br>
data: {<br>
text: 'this is a jsonp api',<br>
time: new Date().getTime(),<br>
}<br>
}<br>
// jsonp的script字符串<br>
let jsonpStr = <code>;${callbackName}(${JSON.stringify(returnData)})</code><br>
ctx.body = jsonpStr<br>
})</p>
<p>router.get('/data1', async (ctx) =&gt; {<br>
let cb = ctx.request.query.callback;<br>
ctx.type = 'text';<br>
ctx.body = cb + '(' + '&quot;数据&quot;' + ')';<br>
})</p>
<p>CORS：<br>
axios.get('http://127.0.0.01:3001/user/list').then(res=&gt;{<br>
console.log(res)<br>
})</p>
<p>const cors = require('koa2-cors');<br>
app.use(async (ctx, next) =&gt; {<br>
// 允许来自所有域名请求<br>
ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);<br>
// 这样就能只允许 http://localhost:8080 这个域名的请求了<br>
// ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8080&quot;);</p>
<pre><code>// 设置所允许的HTTP请求方法
ctx.set(&quot;Access-Control-Allow-Methods&quot;, &quot;OPTIONS, GET, PUT, POST, DELETE&quot;);

// 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段.
ctx.set(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with, accept, origin, content-type&quot;);

// 服务器收到请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。

// Content-Type表示具体请求中的媒体类型信息
ctx.set(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);

// 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。
// 当设置成允许请求携带cookie时，需要保证&quot;Access-Control-Allow-Origin&quot;是服务器有的域名，而不能是&quot;*&quot;;
ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);

// 该字段可选，用来指定本次预检请求的有效期，单位为秒。
// 当请求方法是PUT或DELETE等特殊方法或者Content-Type字段的类型是application/json时，服务器会提前发送一次请求进行验证
// 下面的的设置只本次验证的有效时间，即在该时间段内服务端可以不用进行验证
ctx.set(&quot;Access-Control-Max-Age&quot;, 300);

/*
CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：
    Cache-Control、
    Content-Language、
    Content-Type、
    Expires、
    Last-Modified、
    Pragma。
*/
// 需要获取其他字段时，使用Access-Control-Expose-Headers，
// getResponseHeader('myData')可以返回我们所需的值
ctx.set(&quot;Access-Control-Expose-Headers&quot;, &quot;myData&quot;);

await next();
</code></pre>
<p>})</p>
<p>3 http proxy:</p>
<p>const proxy = require('http-proxy-middleware');<br>
module.exports = function (app) {<br>
app.use(proxy('/api', { target: 'http://localhost:3002/' }));<br>
};</p>
<p>CSRF：<br>
<img src="https://TianhaoXi.github.io/post-images/1597663497671.jpg" alt="" loading="lazy"></p>
<h1 id="回流和重绘">回流和重绘</h1>
<p>https://www.jianshu.com/p/e081f9aa03fb<br>
当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。<br>
当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。<br>
https://blog.csdn.net/binlety/article/details/81390346<br>
https://blog.csdn.net/weixin_30289831/article/details/97202752?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param<br>
https://blog.csdn.net/qq_36360463/article/details/105129688?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</p>
<h1 id="一次性加载一万个标签">一次性加载一万个标签</h1>
<p>document.createDocumentFrament</p>
<script>
	var container = document.getElementById('container')
	var fragment = document.createDocumentFragment()
	for(let i = 0; i < 10000; i++){
		let li = document.createElement('li')
		li.innerHTML = 'hello world'
	    fragment.appendChild(li)
	}
	container.appendChild(fragment);
</script>
<p>前端工程化:<br>
模块化<br>
简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。只有这样，才有多人协作的可能。<br>
组件化</p>
<h1 id="节流和防抖">节流和防抖</h1>
<p>对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。<br>
https://segmentfault.com/a/1190000018428170</p>
<p>function debounce(func,wait){<br>
let timer;</p>
<pre><code>return function(){
    clearTimeout(timer);
    timer = setTimeout(func,wait)
}
</code></pre>
<p>}</p>
<p>function real(){<br>
console.log(&quot;123&quot;);<br>
}</p>
<p>function throttle(func,wait,mustrun){<br>
let timeout,starttime = new Date();</p>
<pre><code>return ()=&gt;{
    let currenttime = new Date();
    clearTimeout(timeout)
    if(currenttime-starttime&gt;mustrun){
        func.apply(this,arguments)
        starttime = currenttime
    }
    else{
        timeout = setTimeout(func,wait)
    }
}
</code></pre>
<p>}</p>
<p>window.addEventListener(&quot;scroll&quot;,throttle(real,1000,1000))</p>
<p>#清除浮动<br>
方法一：使用带clear属性的空元素<br>
在浮动元素后使用一个空元素如<div class="clear"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用<br class="clear" />或<hr class="clear" />来进行清理。</p>
<p>.clearfix:after{/<em>伪元素是行内元素 正常浏览器清除浮动方法</em>/<br>
content: &quot;&quot;;<br>
display: block;<br>
height: 0;<br>
clear:both;<br>
visibility: hidden;<br>
}</p>
<p>BFC:<br>
三、触发 BFC<br>
只要元素满足下面任一条件即可触发 BFC 特性：<br>
body 根元素<br>
浮动元素：float 除 none 以外的值<br>
绝对定位元素：position (absolute、fixed)<br>
display 为 inline-block、table-cells、flex<br>
overflow 除了 visible 以外的值 (hidden、auto、scroll)</p>
<h1 id="css居中">css居中</h1>
<p>行内水平 text-align:center</p>
<p>block居中:<br>
display:flex;<br>
align-items: center;<br>
justify-content:center;</p>
<p>position:absolute;<br>
left:50%;<br>
top:50%;<br>
transform: translate(-50%,-50%);</p>
<p>#左边固定宽度，右边自适应<br>
1.<br>
.left{<br>
float: left;<br>
width: 200px;<br>
background: red;<br>
}<br>
.right{<br>
margin-left: 200px;<br>
background: blue;<br>
}</p>
<ol start="2">
<li>
<p>.right{<br>
overflow: hidden;<br>
background: blue;<br>
}</p>
</li>
<li>
<p>flex:<br>
.wrapper{<br>
display: flex;<br>
}<br>
.left,.right{<br>
height: 100px;<br>
}<br>
.left{<br>
width: 200px;<br>
background: red;<br>
}<br>
.right{<br>
flex: 1;<br>
background: blue;<br>
}</p>
</li>
</ol>
<h1 id="白屏优化">白屏优化</h1>
<p>https://blog.csdn.net/PHPxiaoxuesheng/article/details/100935993</p>
<p>#强缓存与协商缓存<br>
https://www.jianshu.com/p/9c95db596df5<br>
强缓存<br>
到底什么是强缓存？强在哪？其实强是强制的意思。当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制，具体表现为：<br>
respone header 的cache-control，常见的设置是max-age public private no-cache no-store等<br>
如果cahe-control:max-age=315360000,public再加个immutable的话，就算用户刷新页面，浏览器也不会发起请求去服务，浏览器会直接从本地磁盘或者内存中读取缓存并返回200状态</p>
<h1 id="浏览器的线程">浏览器的线程</h1>
<p>https://segmentfault.com/a/1190000013083967</p>
<h1 id="deepclone">deepClone</h1>
<p>function deepClone(target){<br>
let result;<br>
if(typeof result === 'object'){<br>
if(target instanceof Array){<br>
result = [];<br>
for(let i =0;i&lt;tartget.length;i++){<br>
result.push(deepClone(target[i]))<br>
}<br>
}<br>
else if(target ===null){<br>
result = null;<br>
}<br>
else if( target.<strong>proto</strong>.constructor ===RegExp){<br>
result = target;<br>
}<br>
else{<br>
result = {};<br>
for(let i in target){<br>
result[i] = deepClone(target[i])<br>
}<br>
}<br>
}<br>
else{<br>
result = target;<br>
}</p>
<pre><code>return result;
</code></pre>
<p>}</p>
<h1 id="垃圾回收机制">垃圾回收机制</h1>
<p>https://segmentfault.com/a/1190000018605776?utm_source=tag-newest</p>
<h1 id="cors-简单-复杂请求">cors 简单 复杂请求</h1>
<p>https://www.cnblogs.com/qunxiadexiaoxiangjiao/p/9446956.html</p>
<p>#原生jsonP</p>
<script>
let response = ""
function jsonp_callback(data){
    console.log(data)
    response = data;
}
</script>
<script src="http://localhost:3002/api/comment?callback=jsonp_callback_function"">
</script>
<p>#bind curry<br>
Function.prototype.bind = function (context) {<br>
var _this = this<br>
var args = Array.prototype.slice.call(arguments, 1)</p>
<pre><code>return function() {
    return _this.apply(context, args)
}
</code></pre>
<p>}</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E8%AF%B4%E4%B8%80%E4%B8%8Bredux%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5"><strong>说一下redux的几个概念：</strong></a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91">函数的this指向</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">进程和线程</a></li>
<li><a href="#generator">generator</a></li>
<li><a href="#http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%83%A8%E5%88%86">HTTP请求的四个部分：</a></li>
<li><a href="#content-type">content-type</a></li>
<li><a href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0">断点续传</a></li>
<li><a href="#http%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E8%AF%B7%E6%B1%82%E7%9A%84%E6%95%B0%E9%87%8F">http如何控制请求的数量</a></li>
<li><a href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">拥塞控制</a></li>
<li><a href="#cookies-localstorage-sessionstorage">cookies localStorage sessionStorage</a></li>
<li><a href="#%E8%B7%A8%E5%9F%9F%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">跨域和解决方法</a></li>
<li><a href="#%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98">回流和重绘</a></li>
<li><a href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%87%E4%B8%AA%E6%A0%87%E7%AD%BE">一次性加载一万个标签</a></li>
<li><a href="#%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96">节流和防抖</a></li>
<li><a href="#css%E5%B1%85%E4%B8%AD">css居中</a></li>
<li><a href="#%E7%99%BD%E5%B1%8F%E4%BC%98%E5%8C%96">白屏优化</a></li>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BA%BF%E7%A8%8B">浏览器的线程</a></li>
<li><a href="#deepclone">deepClone</a></li>
<li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">垃圾回收机制</a></li>
<li><a href="#cors-%E7%AE%80%E5%8D%95-%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82">cors 简单 复杂请求</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://TianhaoXi.github.io/post/js-de-xiao-zhi-shi-dian/">
              <h3 class="post-title">
                js的小知识点
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://TianhaoXi.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
